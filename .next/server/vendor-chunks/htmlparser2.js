"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/htmlparser2";
exports.ids = ["vendor-chunks/htmlparser2"];
exports.modules = {

/***/ "(ssr)/./node_modules/htmlparser2/dist/commonjs/Parser.js":
/*!**********************************************************!*\
  !*** ./node_modules/htmlparser2/dist/commonjs/Parser.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Parser = void 0;\nconst Tokenizer_js_1 = __importStar(__webpack_require__(/*! ./Tokenizer.js */ \"(ssr)/./node_modules/htmlparser2/dist/commonjs/Tokenizer.js\"));\nconst decode_1 = __webpack_require__(/*! entities/decode */ \"(ssr)/./node_modules/entities/dist/commonjs/decode.js\");\nconst formTags = new Set([\n    \"input\",\n    \"option\",\n    \"optgroup\",\n    \"select\",\n    \"button\",\n    \"datalist\",\n    \"textarea\",\n]);\nconst pTag = new Set([\"p\"]);\nconst tableSectionTags = new Set([\"thead\", \"tbody\"]);\nconst ddtTags = new Set([\"dd\", \"dt\"]);\nconst rtpTags = new Set([\"rt\", \"rp\"]);\nconst openImpliesClose = new Map([\n    [\"tr\", new Set([\"tr\", \"th\", \"td\"])],\n    [\"th\", new Set([\"th\"])],\n    [\"td\", new Set([\"thead\", \"th\", \"td\"])],\n    [\"body\", new Set([\"head\", \"link\", \"script\"])],\n    [\"li\", new Set([\"li\"])],\n    [\"p\", pTag],\n    [\"h1\", pTag],\n    [\"h2\", pTag],\n    [\"h3\", pTag],\n    [\"h4\", pTag],\n    [\"h5\", pTag],\n    [\"h6\", pTag],\n    [\"select\", formTags],\n    [\"input\", formTags],\n    [\"output\", formTags],\n    [\"button\", formTags],\n    [\"datalist\", formTags],\n    [\"textarea\", formTags],\n    [\"option\", new Set([\"option\"])],\n    [\"optgroup\", new Set([\"optgroup\", \"option\"])],\n    [\"dd\", ddtTags],\n    [\"dt\", ddtTags],\n    [\"address\", pTag],\n    [\"article\", pTag],\n    [\"aside\", pTag],\n    [\"blockquote\", pTag],\n    [\"details\", pTag],\n    [\"div\", pTag],\n    [\"dl\", pTag],\n    [\"fieldset\", pTag],\n    [\"figcaption\", pTag],\n    [\"figure\", pTag],\n    [\"footer\", pTag],\n    [\"form\", pTag],\n    [\"header\", pTag],\n    [\"hr\", pTag],\n    [\"main\", pTag],\n    [\"nav\", pTag],\n    [\"ol\", pTag],\n    [\"pre\", pTag],\n    [\"section\", pTag],\n    [\"table\", pTag],\n    [\"ul\", pTag],\n    [\"rt\", rtpTags],\n    [\"rp\", rtpTags],\n    [\"tbody\", tableSectionTags],\n    [\"tfoot\", tableSectionTags],\n]);\nconst voidElements = new Set([\n    \"area\",\n    \"base\",\n    \"basefont\",\n    \"br\",\n    \"col\",\n    \"command\",\n    \"embed\",\n    \"frame\",\n    \"hr\",\n    \"img\",\n    \"input\",\n    \"isindex\",\n    \"keygen\",\n    \"link\",\n    \"meta\",\n    \"param\",\n    \"source\",\n    \"track\",\n    \"wbr\",\n]);\nconst foreignContextElements = new Set([\"math\", \"svg\"]);\nconst htmlIntegrationElements = new Set([\n    \"mi\",\n    \"mo\",\n    \"mn\",\n    \"ms\",\n    \"mtext\",\n    \"annotation-xml\",\n    \"foreignobject\",\n    \"desc\",\n    \"title\",\n]);\nconst reNameEnd = /\\s|\\//;\nclass Parser {\n    constructor(cbs, options = {}) {\n        var _a, _b, _c, _d, _e, _f;\n        this.options = options;\n        /** The start index of the last event. */\n        this.startIndex = 0;\n        /** The end index of the last event. */\n        this.endIndex = 0;\n        /**\n         * Store the start index of the current open tag,\n         * so we can update the start index for attributes.\n         */\n        this.openTagStart = 0;\n        this.tagname = \"\";\n        this.attribname = \"\";\n        this.attribvalue = \"\";\n        this.attribs = null;\n        this.stack = [];\n        this.buffers = [];\n        this.bufferOffset = 0;\n        /** The index of the last written buffer. Used when resuming after a `pause()`. */\n        this.writeIndex = 0;\n        /** Indicates whether the parser has finished running / `.end` has been called. */\n        this.ended = false;\n        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};\n        this.htmlMode = !this.options.xmlMode;\n        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : this.htmlMode;\n        this.lowerCaseAttributeNames =\n            (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : this.htmlMode;\n        this.recognizeSelfClosing =\n            (_c = options.recognizeSelfClosing) !== null && _c !== void 0 ? _c : !this.htmlMode;\n        this.tokenizer = new ((_d = options.Tokenizer) !== null && _d !== void 0 ? _d : Tokenizer_js_1.default)(this.options, this);\n        this.foreignContext = [!this.htmlMode];\n        (_f = (_e = this.cbs).onparserinit) === null || _f === void 0 ? void 0 : _f.call(_e, this);\n    }\n    // Tokenizer event handlers\n    /** @internal */\n    ontext(start, endIndex) {\n        var _a, _b;\n        const data = this.getSlice(start, endIndex);\n        this.endIndex = endIndex - 1;\n        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);\n        this.startIndex = endIndex;\n    }\n    /** @internal */\n    ontextentity(cp, endIndex) {\n        var _a, _b;\n        this.endIndex = endIndex - 1;\n        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_1.fromCodePoint)(cp));\n        this.startIndex = endIndex;\n    }\n    /**\n     * Checks if the current tag is a void element. Override this if you want\n     * to specify your own additional void elements.\n     */\n    isVoidElement(name) {\n        return this.htmlMode && voidElements.has(name);\n    }\n    /** @internal */\n    onopentagname(start, endIndex) {\n        this.endIndex = endIndex;\n        let name = this.getSlice(start, endIndex);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        this.emitOpenTag(name);\n    }\n    emitOpenTag(name) {\n        var _a, _b, _c, _d;\n        this.openTagStart = this.startIndex;\n        this.tagname = name;\n        const impliesClose = this.htmlMode && openImpliesClose.get(name);\n        if (impliesClose) {\n            while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {\n                const element = this.stack.shift();\n                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, true);\n            }\n        }\n        if (!this.isVoidElement(name)) {\n            this.stack.unshift(name);\n            if (this.htmlMode) {\n                if (foreignContextElements.has(name)) {\n                    this.foreignContext.unshift(true);\n                }\n                else if (htmlIntegrationElements.has(name)) {\n                    this.foreignContext.unshift(false);\n                }\n            }\n        }\n        (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);\n        if (this.cbs.onopentag)\n            this.attribs = {};\n    }\n    endOpenTag(isImplied) {\n        var _a, _b;\n        this.startIndex = this.openTagStart;\n        if (this.attribs) {\n            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);\n            this.attribs = null;\n        }\n        if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {\n            this.cbs.onclosetag(this.tagname, true);\n        }\n        this.tagname = \"\";\n    }\n    /** @internal */\n    onopentagend(endIndex) {\n        this.endIndex = endIndex;\n        this.endOpenTag(false);\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    onclosetag(start, endIndex) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        this.endIndex = endIndex;\n        let name = this.getSlice(start, endIndex);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        if (this.htmlMode &&\n            (foreignContextElements.has(name) ||\n                htmlIntegrationElements.has(name))) {\n            this.foreignContext.shift();\n        }\n        if (!this.isVoidElement(name)) {\n            const pos = this.stack.indexOf(name);\n            if (pos !== -1) {\n                for (let index = 0; index <= pos; index++) {\n                    const element = this.stack.shift();\n                    // We know the stack has sufficient elements.\n                    (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, index !== pos);\n                }\n            }\n            else if (this.htmlMode && name === \"p\") {\n                // Implicit open before close\n                this.emitOpenTag(\"p\");\n                this.closeCurrentTag(true);\n            }\n        }\n        else if (this.htmlMode && name === \"br\") {\n            // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.\n            (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, \"br\");\n            (_f = (_e = this.cbs).onopentag) === null || _f === void 0 ? void 0 : _f.call(_e, \"br\", {}, true);\n            (_h = (_g = this.cbs).onclosetag) === null || _h === void 0 ? void 0 : _h.call(_g, \"br\", false);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    onselfclosingtag(endIndex) {\n        this.endIndex = endIndex;\n        if (this.recognizeSelfClosing || this.foreignContext[0]) {\n            this.closeCurrentTag(false);\n            // Set `startIndex` for next node\n            this.startIndex = endIndex + 1;\n        }\n        else {\n            // Ignore the fact that the tag is self-closing.\n            this.onopentagend(endIndex);\n        }\n    }\n    closeCurrentTag(isOpenImplied) {\n        var _a, _b;\n        const name = this.tagname;\n        this.endOpenTag(isOpenImplied);\n        // Self-closing tags will be on the top of the stack\n        if (this.stack[0] === name) {\n            // If the opening tag isn't implied, the closing tag has to be implied.\n            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);\n            this.stack.shift();\n        }\n    }\n    /** @internal */\n    onattribname(start, endIndex) {\n        this.startIndex = start;\n        const name = this.getSlice(start, endIndex);\n        this.attribname = this.lowerCaseAttributeNames\n            ? name.toLowerCase()\n            : name;\n    }\n    /** @internal */\n    onattribdata(start, endIndex) {\n        this.attribvalue += this.getSlice(start, endIndex);\n    }\n    /** @internal */\n    onattribentity(cp) {\n        this.attribvalue += (0, decode_1.fromCodePoint)(cp);\n    }\n    /** @internal */\n    onattribend(quote, endIndex) {\n        var _a, _b;\n        this.endIndex = endIndex;\n        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double\n            ? '\"'\n            : quote === Tokenizer_js_1.QuoteType.Single\n                ? \"'\"\n                : quote === Tokenizer_js_1.QuoteType.NoValue\n                    ? undefined\n                    : null);\n        if (this.attribs &&\n            !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {\n            this.attribs[this.attribname] = this.attribvalue;\n        }\n        this.attribvalue = \"\";\n    }\n    getInstructionName(value) {\n        const index = value.search(reNameEnd);\n        let name = index < 0 ? value : value.substr(0, index);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        return name;\n    }\n    /** @internal */\n    ondeclaration(start, endIndex) {\n        this.endIndex = endIndex;\n        const value = this.getSlice(start, endIndex);\n        if (this.cbs.onprocessinginstruction) {\n            const name = this.getInstructionName(value);\n            this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    onprocessinginstruction(start, endIndex) {\n        this.endIndex = endIndex;\n        const value = this.getSlice(start, endIndex);\n        if (this.cbs.onprocessinginstruction) {\n            const name = this.getInstructionName(value);\n            this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    oncomment(start, endIndex, offset) {\n        var _a, _b, _c, _d;\n        this.endIndex = endIndex;\n        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));\n        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    oncdata(start, endIndex, offset) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        this.endIndex = endIndex;\n        const value = this.getSlice(start, endIndex - offset);\n        if (!this.htmlMode || this.options.recognizeCDATA) {\n            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);\n            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);\n            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);\n        }\n        else {\n            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);\n            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    onend() {\n        var _a, _b;\n        if (this.cbs.onclosetag) {\n            // Set the end index for all remaining tags\n            this.endIndex = this.startIndex;\n            for (let index = 0; index < this.stack.length; index++) {\n                this.cbs.onclosetag(this.stack[index], true);\n            }\n        }\n        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Resets the parser to a blank state, ready to parse a new HTML document\n     */\n    reset() {\n        var _a, _b, _c, _d;\n        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.tokenizer.reset();\n        this.tagname = \"\";\n        this.attribname = \"\";\n        this.attribs = null;\n        this.stack.length = 0;\n        this.startIndex = 0;\n        this.endIndex = 0;\n        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n        this.buffers.length = 0;\n        this.foreignContext.length = 0;\n        this.foreignContext.unshift(!this.htmlMode);\n        this.bufferOffset = 0;\n        this.writeIndex = 0;\n        this.ended = false;\n    }\n    /**\n     * Resets the parser, then parses a complete document and\n     * pushes it to the handler.\n     *\n     * @param data Document to parse.\n     */\n    parseComplete(data) {\n        this.reset();\n        this.end(data);\n    }\n    getSlice(start, end) {\n        while (start - this.bufferOffset >= this.buffers[0].length) {\n            this.shiftBuffer();\n        }\n        let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);\n        while (end - this.bufferOffset > this.buffers[0].length) {\n            this.shiftBuffer();\n            slice += this.buffers[0].slice(0, end - this.bufferOffset);\n        }\n        return slice;\n    }\n    shiftBuffer() {\n        this.bufferOffset += this.buffers[0].length;\n        this.writeIndex--;\n        this.buffers.shift();\n    }\n    /**\n     * Parses a chunk of data and calls the corresponding callbacks.\n     *\n     * @param chunk Chunk to parse.\n     */\n    write(chunk) {\n        var _a, _b;\n        if (this.ended) {\n            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(\".write() after done!\"));\n            return;\n        }\n        this.buffers.push(chunk);\n        if (this.tokenizer.running) {\n            this.tokenizer.write(chunk);\n            this.writeIndex++;\n        }\n    }\n    /**\n     * Parses the end of the buffer and clears the stack, calls onend.\n     *\n     * @param chunk Optional final chunk to parse.\n     */\n    end(chunk) {\n        var _a, _b;\n        if (this.ended) {\n            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(\".end() after done!\"));\n            return;\n        }\n        if (chunk)\n            this.write(chunk);\n        this.ended = true;\n        this.tokenizer.end();\n    }\n    /**\n     * Pauses parsing. The parser won't emit events until `resume` is called.\n     */\n    pause() {\n        this.tokenizer.pause();\n    }\n    /**\n     * Resumes parsing after `pause` was called.\n     */\n    resume() {\n        this.tokenizer.resume();\n        while (this.tokenizer.running &&\n            this.writeIndex < this.buffers.length) {\n            this.tokenizer.write(this.buffers[this.writeIndex++]);\n        }\n        if (this.ended)\n            this.tokenizer.end();\n    }\n    /**\n     * Alias of `write`, for backwards compatibility.\n     *\n     * @param chunk Chunk to parse.\n     * @deprecated\n     */\n    parseChunk(chunk) {\n        this.write(chunk);\n    }\n    /**\n     * Alias of `end`, for backwards compatibility.\n     *\n     * @param chunk Optional final chunk to parse.\n     * @deprecated\n     */\n    done(chunk) {\n        this.end(chunk);\n    }\n}\nexports.Parser = Parser;\n//# sourceMappingURL=Parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvZGlzdC9jb21tb25qcy9QYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLG9DQUFvQyxtQkFBTyxDQUFDLG1GQUFnQjtBQUM1RCxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLLE9BQU8sTUFBTTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLLE9BQU8sTUFBTTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csTUFBTTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyIvaG9tZS96dWJhaXIvZGVzaWduLWluLXN0dWRpby1zZXJ2aWNlL25vZGVfbW9kdWxlcy9odG1scGFyc2VyMi9kaXN0L2NvbW1vbmpzL1BhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBUb2tlbml6ZXJfanNfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9Ub2tlbml6ZXIuanNcIikpO1xuY29uc3QgZGVjb2RlXzEgPSByZXF1aXJlKFwiZW50aXRpZXMvZGVjb2RlXCIpO1xuY29uc3QgZm9ybVRhZ3MgPSBuZXcgU2V0KFtcbiAgICBcImlucHV0XCIsXG4gICAgXCJvcHRpb25cIixcbiAgICBcIm9wdGdyb3VwXCIsXG4gICAgXCJzZWxlY3RcIixcbiAgICBcImJ1dHRvblwiLFxuICAgIFwiZGF0YWxpc3RcIixcbiAgICBcInRleHRhcmVhXCIsXG5dKTtcbmNvbnN0IHBUYWcgPSBuZXcgU2V0KFtcInBcIl0pO1xuY29uc3QgdGFibGVTZWN0aW9uVGFncyA9IG5ldyBTZXQoW1widGhlYWRcIiwgXCJ0Ym9keVwiXSk7XG5jb25zdCBkZHRUYWdzID0gbmV3IFNldChbXCJkZFwiLCBcImR0XCJdKTtcbmNvbnN0IHJ0cFRhZ3MgPSBuZXcgU2V0KFtcInJ0XCIsIFwicnBcIl0pO1xuY29uc3Qgb3BlbkltcGxpZXNDbG9zZSA9IG5ldyBNYXAoW1xuICAgIFtcInRyXCIsIG5ldyBTZXQoW1widHJcIiwgXCJ0aFwiLCBcInRkXCJdKV0sXG4gICAgW1widGhcIiwgbmV3IFNldChbXCJ0aFwiXSldLFxuICAgIFtcInRkXCIsIG5ldyBTZXQoW1widGhlYWRcIiwgXCJ0aFwiLCBcInRkXCJdKV0sXG4gICAgW1wiYm9keVwiLCBuZXcgU2V0KFtcImhlYWRcIiwgXCJsaW5rXCIsIFwic2NyaXB0XCJdKV0sXG4gICAgW1wibGlcIiwgbmV3IFNldChbXCJsaVwiXSldLFxuICAgIFtcInBcIiwgcFRhZ10sXG4gICAgW1wiaDFcIiwgcFRhZ10sXG4gICAgW1wiaDJcIiwgcFRhZ10sXG4gICAgW1wiaDNcIiwgcFRhZ10sXG4gICAgW1wiaDRcIiwgcFRhZ10sXG4gICAgW1wiaDVcIiwgcFRhZ10sXG4gICAgW1wiaDZcIiwgcFRhZ10sXG4gICAgW1wic2VsZWN0XCIsIGZvcm1UYWdzXSxcbiAgICBbXCJpbnB1dFwiLCBmb3JtVGFnc10sXG4gICAgW1wib3V0cHV0XCIsIGZvcm1UYWdzXSxcbiAgICBbXCJidXR0b25cIiwgZm9ybVRhZ3NdLFxuICAgIFtcImRhdGFsaXN0XCIsIGZvcm1UYWdzXSxcbiAgICBbXCJ0ZXh0YXJlYVwiLCBmb3JtVGFnc10sXG4gICAgW1wib3B0aW9uXCIsIG5ldyBTZXQoW1wib3B0aW9uXCJdKV0sXG4gICAgW1wib3B0Z3JvdXBcIiwgbmV3IFNldChbXCJvcHRncm91cFwiLCBcIm9wdGlvblwiXSldLFxuICAgIFtcImRkXCIsIGRkdFRhZ3NdLFxuICAgIFtcImR0XCIsIGRkdFRhZ3NdLFxuICAgIFtcImFkZHJlc3NcIiwgcFRhZ10sXG4gICAgW1wiYXJ0aWNsZVwiLCBwVGFnXSxcbiAgICBbXCJhc2lkZVwiLCBwVGFnXSxcbiAgICBbXCJibG9ja3F1b3RlXCIsIHBUYWddLFxuICAgIFtcImRldGFpbHNcIiwgcFRhZ10sXG4gICAgW1wiZGl2XCIsIHBUYWddLFxuICAgIFtcImRsXCIsIHBUYWddLFxuICAgIFtcImZpZWxkc2V0XCIsIHBUYWddLFxuICAgIFtcImZpZ2NhcHRpb25cIiwgcFRhZ10sXG4gICAgW1wiZmlndXJlXCIsIHBUYWddLFxuICAgIFtcImZvb3RlclwiLCBwVGFnXSxcbiAgICBbXCJmb3JtXCIsIHBUYWddLFxuICAgIFtcImhlYWRlclwiLCBwVGFnXSxcbiAgICBbXCJoclwiLCBwVGFnXSxcbiAgICBbXCJtYWluXCIsIHBUYWddLFxuICAgIFtcIm5hdlwiLCBwVGFnXSxcbiAgICBbXCJvbFwiLCBwVGFnXSxcbiAgICBbXCJwcmVcIiwgcFRhZ10sXG4gICAgW1wic2VjdGlvblwiLCBwVGFnXSxcbiAgICBbXCJ0YWJsZVwiLCBwVGFnXSxcbiAgICBbXCJ1bFwiLCBwVGFnXSxcbiAgICBbXCJydFwiLCBydHBUYWdzXSxcbiAgICBbXCJycFwiLCBydHBUYWdzXSxcbiAgICBbXCJ0Ym9keVwiLCB0YWJsZVNlY3Rpb25UYWdzXSxcbiAgICBbXCJ0Zm9vdFwiLCB0YWJsZVNlY3Rpb25UYWdzXSxcbl0pO1xuY29uc3Qgdm9pZEVsZW1lbnRzID0gbmV3IFNldChbXG4gICAgXCJhcmVhXCIsXG4gICAgXCJiYXNlXCIsXG4gICAgXCJiYXNlZm9udFwiLFxuICAgIFwiYnJcIixcbiAgICBcImNvbFwiLFxuICAgIFwiY29tbWFuZFwiLFxuICAgIFwiZW1iZWRcIixcbiAgICBcImZyYW1lXCIsXG4gICAgXCJoclwiLFxuICAgIFwiaW1nXCIsXG4gICAgXCJpbnB1dFwiLFxuICAgIFwiaXNpbmRleFwiLFxuICAgIFwia2V5Z2VuXCIsXG4gICAgXCJsaW5rXCIsXG4gICAgXCJtZXRhXCIsXG4gICAgXCJwYXJhbVwiLFxuICAgIFwic291cmNlXCIsXG4gICAgXCJ0cmFja1wiLFxuICAgIFwid2JyXCIsXG5dKTtcbmNvbnN0IGZvcmVpZ25Db250ZXh0RWxlbWVudHMgPSBuZXcgU2V0KFtcIm1hdGhcIiwgXCJzdmdcIl0pO1xuY29uc3QgaHRtbEludGVncmF0aW9uRWxlbWVudHMgPSBuZXcgU2V0KFtcbiAgICBcIm1pXCIsXG4gICAgXCJtb1wiLFxuICAgIFwibW5cIixcbiAgICBcIm1zXCIsXG4gICAgXCJtdGV4dFwiLFxuICAgIFwiYW5ub3RhdGlvbi14bWxcIixcbiAgICBcImZvcmVpZ25vYmplY3RcIixcbiAgICBcImRlc2NcIixcbiAgICBcInRpdGxlXCIsXG5dKTtcbmNvbnN0IHJlTmFtZUVuZCA9IC9cXHN8XFwvLztcbmNsYXNzIFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoY2JzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIC8qKiBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIGxhc3QgZXZlbnQuICovXG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIC8qKiBUaGUgZW5kIGluZGV4IG9mIHRoZSBsYXN0IGV2ZW50LiAqL1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlIHRoZSBzdGFydCBpbmRleCBvZiB0aGUgY3VycmVudCBvcGVuIHRhZyxcbiAgICAgICAgICogc28gd2UgY2FuIHVwZGF0ZSB0aGUgc3RhcnQgaW5kZXggZm9yIGF0dHJpYnV0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZW5UYWdTdGFydCA9IDA7XG4gICAgICAgIHRoaXMudGFnbmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cmlibmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cmlidmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJpYnMgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZmZlck9mZnNldCA9IDA7XG4gICAgICAgIC8qKiBUaGUgaW5kZXggb2YgdGhlIGxhc3Qgd3JpdHRlbiBidWZmZXIuIFVzZWQgd2hlbiByZXN1bWluZyBhZnRlciBhIGBwYXVzZSgpYC4gKi9cbiAgICAgICAgdGhpcy53cml0ZUluZGV4ID0gMDtcbiAgICAgICAgLyoqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBwYXJzZXIgaGFzIGZpbmlzaGVkIHJ1bm5pbmcgLyBgLmVuZGAgaGFzIGJlZW4gY2FsbGVkLiAqL1xuICAgICAgICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2JzID0gY2JzICE9PSBudWxsICYmIGNicyAhPT0gdm9pZCAwID8gY2JzIDoge307XG4gICAgICAgIHRoaXMuaHRtbE1vZGUgPSAhdGhpcy5vcHRpb25zLnhtbE1vZGU7XG4gICAgICAgIHRoaXMubG93ZXJDYXNlVGFnTmFtZXMgPSAoX2EgPSBvcHRpb25zLmxvd2VyQ2FzZVRhZ3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuaHRtbE1vZGU7XG4gICAgICAgIHRoaXMubG93ZXJDYXNlQXR0cmlidXRlTmFtZXMgPVxuICAgICAgICAgICAgKF9iID0gb3B0aW9ucy5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5odG1sTW9kZTtcbiAgICAgICAgdGhpcy5yZWNvZ25pemVTZWxmQ2xvc2luZyA9XG4gICAgICAgICAgICAoX2MgPSBvcHRpb25zLnJlY29nbml6ZVNlbGZDbG9zaW5nKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAhdGhpcy5odG1sTW9kZTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSBuZXcgKChfZCA9IG9wdGlvbnMuVG9rZW5pemVyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBUb2tlbml6ZXJfanNfMS5kZWZhdWx0KSh0aGlzLm9wdGlvbnMsIHRoaXMpO1xuICAgICAgICB0aGlzLmZvcmVpZ25Db250ZXh0ID0gWyF0aGlzLmh0bWxNb2RlXTtcbiAgICAgICAgKF9mID0gKF9lID0gdGhpcy5jYnMpLm9ucGFyc2VyaW5pdCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UsIHRoaXMpO1xuICAgIH1cbiAgICAvLyBUb2tlbml6ZXIgZXZlbnQgaGFuZGxlcnNcbiAgICAvKiogQGludGVybmFsICovXG4gICAgb250ZXh0KHN0YXJ0LCBlbmRJbmRleCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRTbGljZShzdGFydCwgZW5kSW5kZXgpO1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXggLSAxO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub250ZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZGF0YSk7XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IGVuZEluZGV4O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgb250ZXh0ZW50aXR5KGNwLCBlbmRJbmRleCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXggLSAxO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub250ZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgKDAsIGRlY29kZV8xLmZyb21Db2RlUG9pbnQpKGNwKSk7XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IGVuZEluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgdGFnIGlzIGEgdm9pZCBlbGVtZW50LiBPdmVycmlkZSB0aGlzIGlmIHlvdSB3YW50XG4gICAgICogdG8gc3BlY2lmeSB5b3VyIG93biBhZGRpdGlvbmFsIHZvaWQgZWxlbWVudHMuXG4gICAgICovXG4gICAgaXNWb2lkRWxlbWVudChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0bWxNb2RlICYmIHZvaWRFbGVtZW50cy5oYXMobmFtZSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbm9wZW50YWduYW1lKHN0YXJ0LCBlbmRJbmRleCkge1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy5nZXRTbGljZShzdGFydCwgZW5kSW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5sb3dlckNhc2VUYWdOYW1lcykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXRPcGVuVGFnKG5hbWUpO1xuICAgIH1cbiAgICBlbWl0T3BlblRhZyhuYW1lKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdGhpcy5vcGVuVGFnU3RhcnQgPSB0aGlzLnN0YXJ0SW5kZXg7XG4gICAgICAgIHRoaXMudGFnbmFtZSA9IG5hbWU7XG4gICAgICAgIGNvbnN0IGltcGxpZXNDbG9zZSA9IHRoaXMuaHRtbE1vZGUgJiYgb3BlbkltcGxpZXNDbG9zZS5nZXQobmFtZSk7XG4gICAgICAgIGlmIChpbXBsaWVzQ2xvc2UpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IDAgJiYgaW1wbGllc0Nsb3NlLmhhcyh0aGlzLnN0YWNrWzBdKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9uY2xvc2V0YWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNWb2lkRWxlbWVudChuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5zdGFjay51bnNoaWZ0KG5hbWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaHRtbE1vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yZWlnbkNvbnRleHRFbGVtZW50cy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JlaWduQ29udGV4dC51bnNoaWZ0KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChodG1sSW50ZWdyYXRpb25FbGVtZW50cy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JlaWduQ29udGV4dC51bnNoaWZ0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKF9kID0gKF9jID0gdGhpcy5jYnMpLm9ub3BlbnRhZ25hbWUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCBuYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuY2JzLm9ub3BlbnRhZylcbiAgICAgICAgICAgIHRoaXMuYXR0cmlicyA9IHt9O1xuICAgIH1cbiAgICBlbmRPcGVuVGFnKGlzSW1wbGllZCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSB0aGlzLm9wZW5UYWdTdGFydDtcbiAgICAgICAgaWYgKHRoaXMuYXR0cmlicykge1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9ub3BlbnRhZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMudGFnbmFtZSwgdGhpcy5hdHRyaWJzLCBpc0ltcGxpZWQpO1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYnMub25jbG9zZXRhZyAmJiB0aGlzLmlzVm9pZEVsZW1lbnQodGhpcy50YWduYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5jYnMub25jbG9zZXRhZyh0aGlzLnRhZ25hbWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFnbmFtZSA9IFwiXCI7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbm9wZW50YWdlbmQoZW5kSW5kZXgpIHtcbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICB0aGlzLmVuZE9wZW5UYWcoZmFsc2UpO1xuICAgICAgICAvLyBTZXQgYHN0YXJ0SW5kZXhgIGZvciBuZXh0IG5vZGVcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gZW5kSW5kZXggKyAxO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgb25jbG9zZXRhZyhzdGFydCwgZW5kSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICBsZXQgbmFtZSA9IHRoaXMuZ2V0U2xpY2Uoc3RhcnQsIGVuZEluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMubG93ZXJDYXNlVGFnTmFtZXMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaHRtbE1vZGUgJiZcbiAgICAgICAgICAgIChmb3JlaWduQ29udGV4dEVsZW1lbnRzLmhhcyhuYW1lKSB8fFxuICAgICAgICAgICAgICAgIGh0bWxJbnRlZ3JhdGlvbkVsZW1lbnRzLmhhcyhuYW1lKSkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9yZWlnbkNvbnRleHQuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNWb2lkRWxlbWVudChuYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gdGhpcy5zdGFjay5pbmRleE9mKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDw9IHBvczsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5zdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBrbm93IHRoZSBzdGFjayBoYXMgc3VmZmljaWVudCBlbGVtZW50cy5cbiAgICAgICAgICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9uY2xvc2V0YWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBlbGVtZW50LCBpbmRleCAhPT0gcG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmh0bWxNb2RlICYmIG5hbWUgPT09IFwicFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gSW1wbGljaXQgb3BlbiBiZWZvcmUgY2xvc2VcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRPcGVuVGFnKFwicFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlQ3VycmVudFRhZyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmh0bWxNb2RlICYmIG5hbWUgPT09IFwiYnJcIikge1xuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgdXNlIGBlbWl0T3BlblRhZ2AgZm9yIGltcGxpY2l0IG9wZW4sIGFzIGBicmAgd291bGQgYmUgaW1wbGljaXRseSBjbG9zZWQuXG4gICAgICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLmNicykub25vcGVudGFnbmFtZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIFwiYnJcIik7XG4gICAgICAgICAgICAoX2YgPSAoX2UgPSB0aGlzLmNicykub25vcGVudGFnKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FsbChfZSwgXCJiclwiLCB7fSwgdHJ1ZSk7XG4gICAgICAgICAgICAoX2ggPSAoX2cgPSB0aGlzLmNicykub25jbG9zZXRhZykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmNhbGwoX2csIFwiYnJcIiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBgc3RhcnRJbmRleGAgZm9yIG5leHQgbm9kZVxuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSBlbmRJbmRleCArIDE7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbnNlbGZjbG9zaW5ndGFnKGVuZEluZGV4KSB7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgICAgaWYgKHRoaXMucmVjb2duaXplU2VsZkNsb3NpbmcgfHwgdGhpcy5mb3JlaWduQ29udGV4dFswXSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUN1cnJlbnRUYWcoZmFsc2UpO1xuICAgICAgICAgICAgLy8gU2V0IGBzdGFydEluZGV4YCBmb3IgbmV4dCBub2RlXG4gICAgICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSBlbmRJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgdGhlIGZhY3QgdGhhdCB0aGUgdGFnIGlzIHNlbGYtY2xvc2luZy5cbiAgICAgICAgICAgIHRoaXMub25vcGVudGFnZW5kKGVuZEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZUN1cnJlbnRUYWcoaXNPcGVuSW1wbGllZCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy50YWduYW1lO1xuICAgICAgICB0aGlzLmVuZE9wZW5UYWcoaXNPcGVuSW1wbGllZCk7XG4gICAgICAgIC8vIFNlbGYtY2xvc2luZyB0YWdzIHdpbGwgYmUgb24gdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgICAgaWYgKHRoaXMuc3RhY2tbMF0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvcGVuaW5nIHRhZyBpc24ndCBpbXBsaWVkLCB0aGUgY2xvc2luZyB0YWcgaGFzIHRvIGJlIGltcGxpZWQuXG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25jbG9zZXRhZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG5hbWUsICFpc09wZW5JbXBsaWVkKTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2suc2hpZnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgb25hdHRyaWJuYW1lKHN0YXJ0LCBlbmRJbmRleCkge1xuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSBzdGFydDtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0U2xpY2Uoc3RhcnQsIGVuZEluZGV4KTtcbiAgICAgICAgdGhpcy5hdHRyaWJuYW1lID0gdGhpcy5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lc1xuICAgICAgICAgICAgPyBuYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIDogbmFtZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9uYXR0cmliZGF0YShzdGFydCwgZW5kSW5kZXgpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ2YWx1ZSArPSB0aGlzLmdldFNsaWNlKHN0YXJ0LCBlbmRJbmRleCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbmF0dHJpYmVudGl0eShjcCkge1xuICAgICAgICB0aGlzLmF0dHJpYnZhbHVlICs9ICgwLCBkZWNvZGVfMS5mcm9tQ29kZVBvaW50KShjcCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbmF0dHJpYmVuZChxdW90ZSwgZW5kSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25hdHRyaWJ1dGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB0aGlzLmF0dHJpYm5hbWUsIHRoaXMuYXR0cmlidmFsdWUsIHF1b3RlID09PSBUb2tlbml6ZXJfanNfMS5RdW90ZVR5cGUuRG91YmxlXG4gICAgICAgICAgICA/ICdcIidcbiAgICAgICAgICAgIDogcXVvdGUgPT09IFRva2VuaXplcl9qc18xLlF1b3RlVHlwZS5TaW5nbGVcbiAgICAgICAgICAgICAgICA/IFwiJ1wiXG4gICAgICAgICAgICAgICAgOiBxdW90ZSA9PT0gVG9rZW5pemVyX2pzXzEuUXVvdGVUeXBlLk5vVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsKTtcbiAgICAgICAgaWYgKHRoaXMuYXR0cmlicyAmJlxuICAgICAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnMsIHRoaXMuYXR0cmlibmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlic1t0aGlzLmF0dHJpYm5hbWVdID0gdGhpcy5hdHRyaWJ2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF0dHJpYnZhbHVlID0gXCJcIjtcbiAgICB9XG4gICAgZ2V0SW5zdHJ1Y3Rpb25OYW1lKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdmFsdWUuc2VhcmNoKHJlTmFtZUVuZCk7XG4gICAgICAgIGxldCBuYW1lID0gaW5kZXggPCAwID8gdmFsdWUgOiB2YWx1ZS5zdWJzdHIoMCwgaW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5sb3dlckNhc2VUYWdOYW1lcykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9uZGVjbGFyYXRpb24oc3RhcnQsIGVuZEluZGV4KSB7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFNsaWNlKHN0YXJ0LCBlbmRJbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmNicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0SW5zdHJ1Y3Rpb25OYW1lKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKGAhJHtuYW1lfWAsIGAhJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgYHN0YXJ0SW5kZXhgIGZvciBuZXh0IG5vZGVcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gZW5kSW5kZXggKyAxO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgb25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24oc3RhcnQsIGVuZEluZGV4KSB7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFNsaWNlKHN0YXJ0LCBlbmRJbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmNicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0SW5zdHJ1Y3Rpb25OYW1lKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKGA/JHtuYW1lfWAsIGA/JHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgYHN0YXJ0SW5kZXhgIGZvciBuZXh0IG5vZGVcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gZW5kSW5kZXggKyAxO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgb25jb21tZW50KHN0YXJ0LCBlbmRJbmRleCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25jb21tZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcy5nZXRTbGljZShzdGFydCwgZW5kSW5kZXggLSBvZmZzZXQpKTtcbiAgICAgICAgKF9kID0gKF9jID0gdGhpcy5jYnMpLm9uY29tbWVudGVuZCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpO1xuICAgICAgICAvLyBTZXQgYHN0YXJ0SW5kZXhgIGZvciBuZXh0IG5vZGVcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gZW5kSW5kZXggKyAxO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgb25jZGF0YShzdGFydCwgZW5kSW5kZXgsIG9mZnNldCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2s7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFNsaWNlKHN0YXJ0LCBlbmRJbmRleCAtIG9mZnNldCk7XG4gICAgICAgIGlmICghdGhpcy5odG1sTW9kZSB8fCB0aGlzLm9wdGlvbnMucmVjb2duaXplQ0RBVEEpIHtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbmNkYXRhc3RhcnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgIChfZCA9IChfYyA9IHRoaXMuY2JzKS5vbnRleHQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCB2YWx1ZSk7XG4gICAgICAgICAgICAoX2YgPSAoX2UgPSB0aGlzLmNicykub25jZGF0YWVuZCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKF9oID0gKF9nID0gdGhpcy5jYnMpLm9uY29tbWVudCkgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmNhbGwoX2csIGBbQ0RBVEFbJHt2YWx1ZX1dXWApO1xuICAgICAgICAgICAgKF9rID0gKF9qID0gdGhpcy5jYnMpLm9uY29tbWVudGVuZCkgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLmNhbGwoX2opO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBgc3RhcnRJbmRleGAgZm9yIG5leHQgbm9kZVxuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSBlbmRJbmRleCArIDE7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbmVuZCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuY2JzLm9uY2xvc2V0YWcpIHtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgZW5kIGluZGV4IGZvciBhbGwgcmVtYWluaW5nIHRhZ3NcbiAgICAgICAgICAgIHRoaXMuZW5kSW5kZXggPSB0aGlzLnN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5zdGFjay5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNicy5vbmNsb3NldGFnKHRoaXMuc3RhY2tbaW5kZXhdLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25lbmQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBwYXJzZXIgdG8gYSBibGFuayBzdGF0ZSwgcmVhZHkgdG8gcGFyc2UgYSBuZXcgSFRNTCBkb2N1bWVudFxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbnJlc2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIHRoaXMudG9rZW5pemVyLnJlc2V0KCk7XG4gICAgICAgIHRoaXMudGFnbmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cmlibmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cmlicyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IDA7XG4gICAgICAgIChfZCA9IChfYyA9IHRoaXMuY2JzKS5vbnBhcnNlcmluaXQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCB0aGlzKTtcbiAgICAgICAgdGhpcy5idWZmZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuZm9yZWlnbkNvbnRleHQubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5mb3JlaWduQ29udGV4dC51bnNoaWZ0KCF0aGlzLmh0bWxNb2RlKTtcbiAgICAgICAgdGhpcy5idWZmZXJPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLndyaXRlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgcGFyc2VyLCB0aGVuIHBhcnNlcyBhIGNvbXBsZXRlIGRvY3VtZW50IGFuZFxuICAgICAqIHB1c2hlcyBpdCB0byB0aGUgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIERvY3VtZW50IHRvIHBhcnNlLlxuICAgICAqL1xuICAgIHBhcnNlQ29tcGxldGUoZGF0YSkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZW5kKGRhdGEpO1xuICAgIH1cbiAgICBnZXRTbGljZShzdGFydCwgZW5kKSB7XG4gICAgICAgIHdoaWxlIChzdGFydCAtIHRoaXMuYnVmZmVyT2Zmc2V0ID49IHRoaXMuYnVmZmVyc1swXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLmJ1ZmZlcnNbMF0uc2xpY2Uoc3RhcnQgLSB0aGlzLmJ1ZmZlck9mZnNldCwgZW5kIC0gdGhpcy5idWZmZXJPZmZzZXQpO1xuICAgICAgICB3aGlsZSAoZW5kIC0gdGhpcy5idWZmZXJPZmZzZXQgPiB0aGlzLmJ1ZmZlcnNbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0QnVmZmVyKCk7XG4gICAgICAgICAgICBzbGljZSArPSB0aGlzLmJ1ZmZlcnNbMF0uc2xpY2UoMCwgZW5kIC0gdGhpcy5idWZmZXJPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzbGljZTtcbiAgICB9XG4gICAgc2hpZnRCdWZmZXIoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyT2Zmc2V0ICs9IHRoaXMuYnVmZmVyc1swXS5sZW5ndGg7XG4gICAgICAgIHRoaXMud3JpdGVJbmRleC0tO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMuc2hpZnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgY2h1bmsgb2YgZGF0YSBhbmQgY2FsbHMgdGhlIGNvcnJlc3BvbmRpbmcgY2FsbGJhY2tzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNodW5rIENodW5rIHRvIHBhcnNlLlxuICAgICAqL1xuICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25lcnJvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG5ldyBFcnJvcihcIi53cml0ZSgpIGFmdGVyIGRvbmUhXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICAgIGlmICh0aGlzLnRva2VuaXplci5ydW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuaXplci53cml0ZShjaHVuayk7XG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXgrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGFuZCBjbGVhcnMgdGhlIHN0YWNrLCBjYWxscyBvbmVuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaHVuayBPcHRpb25hbCBmaW5hbCBjaHVuayB0byBwYXJzZS5cbiAgICAgKi9cbiAgICBlbmQoY2h1bmspIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbmVycm9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgbmV3IEVycm9yKFwiLmVuZCgpIGFmdGVyIGRvbmUhXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2h1bmspXG4gICAgICAgICAgICB0aGlzLndyaXRlKGNodW5rKTtcbiAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudG9rZW5pemVyLmVuZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgcGFyc2luZy4gVGhlIHBhcnNlciB3b24ndCBlbWl0IGV2ZW50cyB1bnRpbCBgcmVzdW1lYCBpcyBjYWxsZWQuXG4gICAgICovXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMudG9rZW5pemVyLnBhdXNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgcGFyc2luZyBhZnRlciBgcGF1c2VgIHdhcyBjYWxsZWQuXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLnRva2VuaXplci5yZXN1bWUoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMudG9rZW5pemVyLnJ1bm5pbmcgJiZcbiAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleCA8IHRoaXMuYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW5pemVyLndyaXRlKHRoaXMuYnVmZmVyc1t0aGlzLndyaXRlSW5kZXgrK10pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKVxuICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIuZW5kKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIG9mIGB3cml0ZWAsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaHVuayBDaHVuayB0byBwYXJzZS5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIHBhcnNlQ2h1bmsoY2h1bmspIHtcbiAgICAgICAgdGhpcy53cml0ZShjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIG9mIGBlbmRgLCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2h1bmsgT3B0aW9uYWwgZmluYWwgY2h1bmsgdG8gcGFyc2UuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBkb25lKGNodW5rKSB7XG4gICAgICAgIHRoaXMuZW5kKGNodW5rKTtcbiAgICB9XG59XG5leHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhcnNlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/htmlparser2/dist/commonjs/Parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/htmlparser2/dist/commonjs/Tokenizer.js":
/*!*************************************************************!*\
  !*** ./node_modules/htmlparser2/dist/commonjs/Tokenizer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QuoteType = void 0;\nconst decode_1 = __webpack_require__(/*! entities/decode */ \"(ssr)/./node_modules/entities/dist/commonjs/decode.js\");\nvar CharCodes;\n(function (CharCodes) {\n    CharCodes[CharCodes[\"Tab\"] = 9] = \"Tab\";\n    CharCodes[CharCodes[\"NewLine\"] = 10] = \"NewLine\";\n    CharCodes[CharCodes[\"FormFeed\"] = 12] = \"FormFeed\";\n    CharCodes[CharCodes[\"CarriageReturn\"] = 13] = \"CarriageReturn\";\n    CharCodes[CharCodes[\"Space\"] = 32] = \"Space\";\n    CharCodes[CharCodes[\"ExclamationMark\"] = 33] = \"ExclamationMark\";\n    CharCodes[CharCodes[\"Number\"] = 35] = \"Number\";\n    CharCodes[CharCodes[\"Amp\"] = 38] = \"Amp\";\n    CharCodes[CharCodes[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    CharCodes[CharCodes[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n    CharCodes[CharCodes[\"Dash\"] = 45] = \"Dash\";\n    CharCodes[CharCodes[\"Slash\"] = 47] = \"Slash\";\n    CharCodes[CharCodes[\"Zero\"] = 48] = \"Zero\";\n    CharCodes[CharCodes[\"Nine\"] = 57] = \"Nine\";\n    CharCodes[CharCodes[\"Semi\"] = 59] = \"Semi\";\n    CharCodes[CharCodes[\"Lt\"] = 60] = \"Lt\";\n    CharCodes[CharCodes[\"Eq\"] = 61] = \"Eq\";\n    CharCodes[CharCodes[\"Gt\"] = 62] = \"Gt\";\n    CharCodes[CharCodes[\"Questionmark\"] = 63] = \"Questionmark\";\n    CharCodes[CharCodes[\"UpperA\"] = 65] = \"UpperA\";\n    CharCodes[CharCodes[\"LowerA\"] = 97] = \"LowerA\";\n    CharCodes[CharCodes[\"UpperF\"] = 70] = \"UpperF\";\n    CharCodes[CharCodes[\"LowerF\"] = 102] = \"LowerF\";\n    CharCodes[CharCodes[\"UpperZ\"] = 90] = \"UpperZ\";\n    CharCodes[CharCodes[\"LowerZ\"] = 122] = \"LowerZ\";\n    CharCodes[CharCodes[\"LowerX\"] = 120] = \"LowerX\";\n    CharCodes[CharCodes[\"OpeningSquareBracket\"] = 91] = \"OpeningSquareBracket\";\n})(CharCodes || (CharCodes = {}));\n/** All the states the tokenizer can be in. */\nvar State;\n(function (State) {\n    State[State[\"Text\"] = 1] = \"Text\";\n    State[State[\"BeforeTagName\"] = 2] = \"BeforeTagName\";\n    State[State[\"InTagName\"] = 3] = \"InTagName\";\n    State[State[\"InSelfClosingTag\"] = 4] = \"InSelfClosingTag\";\n    State[State[\"BeforeClosingTagName\"] = 5] = \"BeforeClosingTagName\";\n    State[State[\"InClosingTagName\"] = 6] = \"InClosingTagName\";\n    State[State[\"AfterClosingTagName\"] = 7] = \"AfterClosingTagName\";\n    // Attributes\n    State[State[\"BeforeAttributeName\"] = 8] = \"BeforeAttributeName\";\n    State[State[\"InAttributeName\"] = 9] = \"InAttributeName\";\n    State[State[\"AfterAttributeName\"] = 10] = \"AfterAttributeName\";\n    State[State[\"BeforeAttributeValue\"] = 11] = \"BeforeAttributeValue\";\n    State[State[\"InAttributeValueDq\"] = 12] = \"InAttributeValueDq\";\n    State[State[\"InAttributeValueSq\"] = 13] = \"InAttributeValueSq\";\n    State[State[\"InAttributeValueNq\"] = 14] = \"InAttributeValueNq\";\n    // Declarations\n    State[State[\"BeforeDeclaration\"] = 15] = \"BeforeDeclaration\";\n    State[State[\"InDeclaration\"] = 16] = \"InDeclaration\";\n    // Processing instructions\n    State[State[\"InProcessingInstruction\"] = 17] = \"InProcessingInstruction\";\n    // Comments & CDATA\n    State[State[\"BeforeComment\"] = 18] = \"BeforeComment\";\n    State[State[\"CDATASequence\"] = 19] = \"CDATASequence\";\n    State[State[\"InSpecialComment\"] = 20] = \"InSpecialComment\";\n    State[State[\"InCommentLike\"] = 21] = \"InCommentLike\";\n    // Special tags\n    State[State[\"BeforeSpecialS\"] = 22] = \"BeforeSpecialS\";\n    State[State[\"BeforeSpecialT\"] = 23] = \"BeforeSpecialT\";\n    State[State[\"SpecialStartSequence\"] = 24] = \"SpecialStartSequence\";\n    State[State[\"InSpecialTag\"] = 25] = \"InSpecialTag\";\n    State[State[\"InEntity\"] = 26] = \"InEntity\";\n})(State || (State = {}));\nfunction isWhitespace(c) {\n    return (c === CharCodes.Space ||\n        c === CharCodes.NewLine ||\n        c === CharCodes.Tab ||\n        c === CharCodes.FormFeed ||\n        c === CharCodes.CarriageReturn);\n}\nfunction isEndOfTagSection(c) {\n    return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);\n}\nfunction isASCIIAlpha(c) {\n    return ((c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||\n        (c >= CharCodes.UpperA && c <= CharCodes.UpperZ));\n}\nvar QuoteType;\n(function (QuoteType) {\n    QuoteType[QuoteType[\"NoValue\"] = 0] = \"NoValue\";\n    QuoteType[QuoteType[\"Unquoted\"] = 1] = \"Unquoted\";\n    QuoteType[QuoteType[\"Single\"] = 2] = \"Single\";\n    QuoteType[QuoteType[\"Double\"] = 3] = \"Double\";\n})(QuoteType || (exports.QuoteType = QuoteType = {}));\n/**\n * Sequences used to match longer strings.\n *\n * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End\n * sequences with an increased offset.\n */\nconst Sequences = {\n    Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]), // CDATA[\n    CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]), // ]]>\n    CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]), // `-->`\n    ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]), // `</script`\n    StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]), // `</style`\n    TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`\n    TextareaEnd: new Uint8Array([\n        0x3c, 0x2f, 0x74, 0x65, 0x78, 0x74, 0x61, 0x72, 0x65, 0x61,\n    ]), // `</textarea`\n    XmpEnd: new Uint8Array([0x3c, 0x2f, 0x78, 0x6d, 0x70]), // `</xmp`\n};\nclass Tokenizer {\n    constructor({ xmlMode = false, decodeEntities = true, }, cbs) {\n        this.cbs = cbs;\n        /** The current state the tokenizer is in. */\n        this.state = State.Text;\n        /** The read buffer. */\n        this.buffer = \"\";\n        /** The beginning of the section that is currently being read. */\n        this.sectionStart = 0;\n        /** The index within the buffer that we are currently looking at. */\n        this.index = 0;\n        /** The start of the last entity. */\n        this.entityStart = 0;\n        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */\n        this.baseState = State.Text;\n        /** For special parsing behavior inside of script and style tags. */\n        this.isSpecial = false;\n        /** Indicates whether the tokenizer has been paused. */\n        this.running = true;\n        /** The offset of the current buffer. */\n        this.offset = 0;\n        this.currentSequence = undefined;\n        this.sequenceIndex = 0;\n        this.xmlMode = xmlMode;\n        this.decodeEntities = decodeEntities;\n        this.entityDecoder = new decode_1.EntityDecoder(xmlMode ? decode_1.xmlDecodeTree : decode_1.htmlDecodeTree, (cp, consumed) => this.emitCodePoint(cp, consumed));\n    }\n    reset() {\n        this.state = State.Text;\n        this.buffer = \"\";\n        this.sectionStart = 0;\n        this.index = 0;\n        this.baseState = State.Text;\n        this.currentSequence = undefined;\n        this.running = true;\n        this.offset = 0;\n    }\n    write(chunk) {\n        this.offset += this.buffer.length;\n        this.buffer = chunk;\n        this.parse();\n    }\n    end() {\n        if (this.running)\n            this.finish();\n    }\n    pause() {\n        this.running = false;\n    }\n    resume() {\n        this.running = true;\n        if (this.index < this.buffer.length + this.offset) {\n            this.parse();\n        }\n    }\n    stateText(c) {\n        if (c === CharCodes.Lt ||\n            (!this.decodeEntities && this.fastForwardTo(CharCodes.Lt))) {\n            if (this.index > this.sectionStart) {\n                this.cbs.ontext(this.sectionStart, this.index);\n            }\n            this.state = State.BeforeTagName;\n            this.sectionStart = this.index;\n        }\n        else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.startEntity();\n        }\n    }\n    stateSpecialStartSequence(c) {\n        const isEnd = this.sequenceIndex === this.currentSequence.length;\n        const isMatch = isEnd\n            ? // If we are at the end of the sequence, make sure the tag name has ended\n                isEndOfTagSection(c)\n            : // Otherwise, do a case-insensitive comparison\n                (c | 0x20) === this.currentSequence[this.sequenceIndex];\n        if (!isMatch) {\n            this.isSpecial = false;\n        }\n        else if (!isEnd) {\n            this.sequenceIndex++;\n            return;\n        }\n        this.sequenceIndex = 0;\n        this.state = State.InTagName;\n        this.stateInTagName(c);\n    }\n    /** Look for an end tag. For <title> tags, also decode entities. */\n    stateInSpecialTag(c) {\n        if (this.sequenceIndex === this.currentSequence.length) {\n            if (c === CharCodes.Gt || isWhitespace(c)) {\n                const endOfText = this.index - this.currentSequence.length;\n                if (this.sectionStart < endOfText) {\n                    // Spoof the index so that reported locations match up.\n                    const actualIndex = this.index;\n                    this.index = endOfText;\n                    this.cbs.ontext(this.sectionStart, endOfText);\n                    this.index = actualIndex;\n                }\n                this.isSpecial = false;\n                this.sectionStart = endOfText + 2; // Skip over the `</`\n                this.stateInClosingTagName(c);\n                return; // We are done; skip the rest of the function.\n            }\n            this.sequenceIndex = 0;\n        }\n        if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {\n            this.sequenceIndex += 1;\n        }\n        else if (this.sequenceIndex === 0) {\n            if (this.currentSequence === Sequences.TitleEnd) {\n                // We have to parse entities in <title> tags.\n                if (this.decodeEntities && c === CharCodes.Amp) {\n                    this.startEntity();\n                }\n            }\n            else if (this.fastForwardTo(CharCodes.Lt)) {\n                // Outside of <title> tags, we can fast-forward.\n                this.sequenceIndex = 1;\n            }\n        }\n        else {\n            // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.\n            this.sequenceIndex = Number(c === CharCodes.Lt);\n        }\n    }\n    stateCDATASequence(c) {\n        if (c === Sequences.Cdata[this.sequenceIndex]) {\n            if (++this.sequenceIndex === Sequences.Cdata.length) {\n                this.state = State.InCommentLike;\n                this.currentSequence = Sequences.CdataEnd;\n                this.sequenceIndex = 0;\n                this.sectionStart = this.index + 1;\n            }\n        }\n        else {\n            this.sequenceIndex = 0;\n            this.state = State.InDeclaration;\n            this.stateInDeclaration(c); // Reconsume the character\n        }\n    }\n    /**\n     * When we wait for one specific character, we can speed things up\n     * by skipping through the buffer until we find it.\n     *\n     * @returns Whether the character was found.\n     */\n    fastForwardTo(c) {\n        while (++this.index < this.buffer.length + this.offset) {\n            if (this.buffer.charCodeAt(this.index - this.offset) === c) {\n                return true;\n            }\n        }\n        /*\n         * We increment the index at the end of the `parse` loop,\n         * so set it to `buffer.length - 1` here.\n         *\n         * TODO: Refactor `parse` to increment index before calling states.\n         */\n        this.index = this.buffer.length + this.offset - 1;\n        return false;\n    }\n    /**\n     * Comments and CDATA end with `-->` and `]]>`.\n     *\n     * Their common qualities are:\n     * - Their end sequences have a distinct character they start with.\n     * - That character is then repeated, so we have to check multiple repeats.\n     * - All characters but the start character of the sequence can be skipped.\n     */\n    stateInCommentLike(c) {\n        if (c === this.currentSequence[this.sequenceIndex]) {\n            if (++this.sequenceIndex === this.currentSequence.length) {\n                if (this.currentSequence === Sequences.CdataEnd) {\n                    this.cbs.oncdata(this.sectionStart, this.index, 2);\n                }\n                else {\n                    this.cbs.oncomment(this.sectionStart, this.index, 2);\n                }\n                this.sequenceIndex = 0;\n                this.sectionStart = this.index + 1;\n                this.state = State.Text;\n            }\n        }\n        else if (this.sequenceIndex === 0) {\n            // Fast-forward to the first character of the sequence\n            if (this.fastForwardTo(this.currentSequence[0])) {\n                this.sequenceIndex = 1;\n            }\n        }\n        else if (c !== this.currentSequence[this.sequenceIndex - 1]) {\n            // Allow long sequences, eg. --->, ]]]>\n            this.sequenceIndex = 0;\n        }\n    }\n    /**\n     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.\n     *\n     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).\n     * We allow anything that wouldn't end the tag.\n     */\n    isTagStartChar(c) {\n        return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);\n    }\n    startSpecial(sequence, offset) {\n        this.isSpecial = true;\n        this.currentSequence = sequence;\n        this.sequenceIndex = offset;\n        this.state = State.SpecialStartSequence;\n    }\n    stateBeforeTagName(c) {\n        if (c === CharCodes.ExclamationMark) {\n            this.state = State.BeforeDeclaration;\n            this.sectionStart = this.index + 1;\n        }\n        else if (c === CharCodes.Questionmark) {\n            this.state = State.InProcessingInstruction;\n            this.sectionStart = this.index + 1;\n        }\n        else if (this.isTagStartChar(c)) {\n            const lower = c | 0x20;\n            this.sectionStart = this.index;\n            if (this.xmlMode) {\n                this.state = State.InTagName;\n            }\n            else if (lower === Sequences.ScriptEnd[2]) {\n                this.state = State.BeforeSpecialS;\n            }\n            else if (lower === Sequences.TitleEnd[2] ||\n                lower === Sequences.XmpEnd[2]) {\n                this.state = State.BeforeSpecialT;\n            }\n            else {\n                this.state = State.InTagName;\n            }\n        }\n        else if (c === CharCodes.Slash) {\n            this.state = State.BeforeClosingTagName;\n        }\n        else {\n            this.state = State.Text;\n            this.stateText(c);\n        }\n    }\n    stateInTagName(c) {\n        if (isEndOfTagSection(c)) {\n            this.cbs.onopentagname(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n    }\n    stateBeforeClosingTagName(c) {\n        if (isWhitespace(c)) {\n            // Ignore\n        }\n        else if (c === CharCodes.Gt) {\n            this.state = State.Text;\n        }\n        else {\n            this.state = this.isTagStartChar(c)\n                ? State.InClosingTagName\n                : State.InSpecialComment;\n            this.sectionStart = this.index;\n        }\n    }\n    stateInClosingTagName(c) {\n        if (c === CharCodes.Gt || isWhitespace(c)) {\n            this.cbs.onclosetag(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.state = State.AfterClosingTagName;\n            this.stateAfterClosingTagName(c);\n        }\n    }\n    stateAfterClosingTagName(c) {\n        // Skip everything until \">\"\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    }\n    stateBeforeAttributeName(c) {\n        if (c === CharCodes.Gt) {\n            this.cbs.onopentagend(this.index);\n            if (this.isSpecial) {\n                this.state = State.InSpecialTag;\n                this.sequenceIndex = 0;\n            }\n            else {\n                this.state = State.Text;\n            }\n            this.sectionStart = this.index + 1;\n        }\n        else if (c === CharCodes.Slash) {\n            this.state = State.InSelfClosingTag;\n        }\n        else if (!isWhitespace(c)) {\n            this.state = State.InAttributeName;\n            this.sectionStart = this.index;\n        }\n    }\n    stateInSelfClosingTag(c) {\n        if (c === CharCodes.Gt) {\n            this.cbs.onselfclosingtag(this.index);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n            this.isSpecial = false; // Reset special state, in case of self-closing special tags\n        }\n        else if (!isWhitespace(c)) {\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n    }\n    stateInAttributeName(c) {\n        if (c === CharCodes.Eq || isEndOfTagSection(c)) {\n            this.cbs.onattribname(this.sectionStart, this.index);\n            this.sectionStart = this.index;\n            this.state = State.AfterAttributeName;\n            this.stateAfterAttributeName(c);\n        }\n    }\n    stateAfterAttributeName(c) {\n        if (c === CharCodes.Eq) {\n            this.state = State.BeforeAttributeValue;\n        }\n        else if (c === CharCodes.Slash || c === CharCodes.Gt) {\n            this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);\n            this.sectionStart = -1;\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n        else if (!isWhitespace(c)) {\n            this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);\n            this.state = State.InAttributeName;\n            this.sectionStart = this.index;\n        }\n    }\n    stateBeforeAttributeValue(c) {\n        if (c === CharCodes.DoubleQuote) {\n            this.state = State.InAttributeValueDq;\n            this.sectionStart = this.index + 1;\n        }\n        else if (c === CharCodes.SingleQuote) {\n            this.state = State.InAttributeValueSq;\n            this.sectionStart = this.index + 1;\n        }\n        else if (!isWhitespace(c)) {\n            this.sectionStart = this.index;\n            this.state = State.InAttributeValueNq;\n            this.stateInAttributeValueNoQuotes(c); // Reconsume token\n        }\n    }\n    handleInAttributeValue(c, quote) {\n        if (c === quote ||\n            (!this.decodeEntities && this.fastForwardTo(quote))) {\n            this.cbs.onattribdata(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.cbs.onattribend(quote === CharCodes.DoubleQuote\n                ? QuoteType.Double\n                : QuoteType.Single, this.index + 1);\n            this.state = State.BeforeAttributeName;\n        }\n        else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.startEntity();\n        }\n    }\n    stateInAttributeValueDoubleQuotes(c) {\n        this.handleInAttributeValue(c, CharCodes.DoubleQuote);\n    }\n    stateInAttributeValueSingleQuotes(c) {\n        this.handleInAttributeValue(c, CharCodes.SingleQuote);\n    }\n    stateInAttributeValueNoQuotes(c) {\n        if (isWhitespace(c) || c === CharCodes.Gt) {\n            this.cbs.onattribdata(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.cbs.onattribend(QuoteType.Unquoted, this.index);\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n        else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.startEntity();\n        }\n    }\n    stateBeforeDeclaration(c) {\n        if (c === CharCodes.OpeningSquareBracket) {\n            this.state = State.CDATASequence;\n            this.sequenceIndex = 0;\n        }\n        else {\n            this.state =\n                c === CharCodes.Dash\n                    ? State.BeforeComment\n                    : State.InDeclaration;\n        }\n    }\n    stateInDeclaration(c) {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.ondeclaration(this.sectionStart, this.index);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    }\n    stateInProcessingInstruction(c) {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.onprocessinginstruction(this.sectionStart, this.index);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    }\n    stateBeforeComment(c) {\n        if (c === CharCodes.Dash) {\n            this.state = State.InCommentLike;\n            this.currentSequence = Sequences.CommentEnd;\n            // Allow short comments (eg. <!-->)\n            this.sequenceIndex = 2;\n            this.sectionStart = this.index + 1;\n        }\n        else {\n            this.state = State.InDeclaration;\n        }\n    }\n    stateInSpecialComment(c) {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.oncomment(this.sectionStart, this.index, 0);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    }\n    stateBeforeSpecialS(c) {\n        const lower = c | 0x20;\n        if (lower === Sequences.ScriptEnd[3]) {\n            this.startSpecial(Sequences.ScriptEnd, 4);\n        }\n        else if (lower === Sequences.StyleEnd[3]) {\n            this.startSpecial(Sequences.StyleEnd, 4);\n        }\n        else {\n            this.state = State.InTagName;\n            this.stateInTagName(c); // Consume the token again\n        }\n    }\n    stateBeforeSpecialT(c) {\n        const lower = c | 0x20;\n        switch (lower) {\n            case Sequences.TitleEnd[3]: {\n                this.startSpecial(Sequences.TitleEnd, 4);\n                break;\n            }\n            case Sequences.TextareaEnd[3]: {\n                this.startSpecial(Sequences.TextareaEnd, 4);\n                break;\n            }\n            case Sequences.XmpEnd[3]: {\n                this.startSpecial(Sequences.XmpEnd, 4);\n                break;\n            }\n            default: {\n                this.state = State.InTagName;\n                this.stateInTagName(c); // Consume the token again\n            }\n        }\n    }\n    startEntity() {\n        this.baseState = this.state;\n        this.state = State.InEntity;\n        this.entityStart = this.index;\n        this.entityDecoder.startEntity(this.xmlMode\n            ? decode_1.DecodingMode.Strict\n            : this.baseState === State.Text ||\n                this.baseState === State.InSpecialTag\n                ? decode_1.DecodingMode.Legacy\n                : decode_1.DecodingMode.Attribute);\n    }\n    stateInEntity() {\n        const length = this.entityDecoder.write(this.buffer, this.index - this.offset);\n        // If `length` is positive, we are done with the entity.\n        if (length >= 0) {\n            this.state = this.baseState;\n            if (length === 0) {\n                this.index = this.entityStart;\n            }\n        }\n        else {\n            // Mark buffer as consumed.\n            this.index = this.offset + this.buffer.length - 1;\n        }\n    }\n    /**\n     * Remove data that has already been consumed from the buffer.\n     */\n    cleanup() {\n        // If we are inside of text or attributes, emit what we already have.\n        if (this.running && this.sectionStart !== this.index) {\n            if (this.state === State.Text ||\n                (this.state === State.InSpecialTag && this.sequenceIndex === 0)) {\n                this.cbs.ontext(this.sectionStart, this.index);\n                this.sectionStart = this.index;\n            }\n            else if (this.state === State.InAttributeValueDq ||\n                this.state === State.InAttributeValueSq ||\n                this.state === State.InAttributeValueNq) {\n                this.cbs.onattribdata(this.sectionStart, this.index);\n                this.sectionStart = this.index;\n            }\n        }\n    }\n    shouldContinue() {\n        return this.index < this.buffer.length + this.offset && this.running;\n    }\n    /**\n     * Iterates through the buffer, calling the function corresponding to the current state.\n     *\n     * States that are more likely to be hit are higher up, as a performance improvement.\n     */\n    parse() {\n        while (this.shouldContinue()) {\n            const c = this.buffer.charCodeAt(this.index - this.offset);\n            switch (this.state) {\n                case State.Text: {\n                    this.stateText(c);\n                    break;\n                }\n                case State.SpecialStartSequence: {\n                    this.stateSpecialStartSequence(c);\n                    break;\n                }\n                case State.InSpecialTag: {\n                    this.stateInSpecialTag(c);\n                    break;\n                }\n                case State.CDATASequence: {\n                    this.stateCDATASequence(c);\n                    break;\n                }\n                case State.InAttributeValueDq: {\n                    this.stateInAttributeValueDoubleQuotes(c);\n                    break;\n                }\n                case State.InAttributeName: {\n                    this.stateInAttributeName(c);\n                    break;\n                }\n                case State.InCommentLike: {\n                    this.stateInCommentLike(c);\n                    break;\n                }\n                case State.InSpecialComment: {\n                    this.stateInSpecialComment(c);\n                    break;\n                }\n                case State.BeforeAttributeName: {\n                    this.stateBeforeAttributeName(c);\n                    break;\n                }\n                case State.InTagName: {\n                    this.stateInTagName(c);\n                    break;\n                }\n                case State.InClosingTagName: {\n                    this.stateInClosingTagName(c);\n                    break;\n                }\n                case State.BeforeTagName: {\n                    this.stateBeforeTagName(c);\n                    break;\n                }\n                case State.AfterAttributeName: {\n                    this.stateAfterAttributeName(c);\n                    break;\n                }\n                case State.InAttributeValueSq: {\n                    this.stateInAttributeValueSingleQuotes(c);\n                    break;\n                }\n                case State.BeforeAttributeValue: {\n                    this.stateBeforeAttributeValue(c);\n                    break;\n                }\n                case State.BeforeClosingTagName: {\n                    this.stateBeforeClosingTagName(c);\n                    break;\n                }\n                case State.AfterClosingTagName: {\n                    this.stateAfterClosingTagName(c);\n                    break;\n                }\n                case State.BeforeSpecialS: {\n                    this.stateBeforeSpecialS(c);\n                    break;\n                }\n                case State.BeforeSpecialT: {\n                    this.stateBeforeSpecialT(c);\n                    break;\n                }\n                case State.InAttributeValueNq: {\n                    this.stateInAttributeValueNoQuotes(c);\n                    break;\n                }\n                case State.InSelfClosingTag: {\n                    this.stateInSelfClosingTag(c);\n                    break;\n                }\n                case State.InDeclaration: {\n                    this.stateInDeclaration(c);\n                    break;\n                }\n                case State.BeforeDeclaration: {\n                    this.stateBeforeDeclaration(c);\n                    break;\n                }\n                case State.BeforeComment: {\n                    this.stateBeforeComment(c);\n                    break;\n                }\n                case State.InProcessingInstruction: {\n                    this.stateInProcessingInstruction(c);\n                    break;\n                }\n                case State.InEntity: {\n                    this.stateInEntity();\n                    break;\n                }\n            }\n            this.index++;\n        }\n        this.cleanup();\n    }\n    finish() {\n        if (this.state === State.InEntity) {\n            this.entityDecoder.end();\n            this.state = this.baseState;\n        }\n        this.handleTrailingData();\n        this.cbs.onend();\n    }\n    /** Handle any trailing data. */\n    handleTrailingData() {\n        const endIndex = this.buffer.length + this.offset;\n        // If there is no remaining data, we are done.\n        if (this.sectionStart >= endIndex) {\n            return;\n        }\n        if (this.state === State.InCommentLike) {\n            if (this.currentSequence === Sequences.CdataEnd) {\n                this.cbs.oncdata(this.sectionStart, endIndex, 0);\n            }\n            else {\n                this.cbs.oncomment(this.sectionStart, endIndex, 0);\n            }\n        }\n        else if (this.state === State.InTagName ||\n            this.state === State.BeforeAttributeName ||\n            this.state === State.BeforeAttributeValue ||\n            this.state === State.AfterAttributeName ||\n            this.state === State.InAttributeName ||\n            this.state === State.InAttributeValueSq ||\n            this.state === State.InAttributeValueDq ||\n            this.state === State.InAttributeValueNq ||\n            this.state === State.InClosingTagName) {\n            /*\n             * If we are currently in an opening or closing tag, us not calling the\n             * respective callback signals that the tag should be ignored.\n             */\n        }\n        else {\n            this.cbs.ontext(this.sectionStart, endIndex);\n        }\n    }\n    emitCodePoint(cp, consumed) {\n        if (this.baseState !== State.Text &&\n            this.baseState !== State.InSpecialTag) {\n            if (this.sectionStart < this.entityStart) {\n                this.cbs.onattribdata(this.sectionStart, this.entityStart);\n            }\n            this.sectionStart = this.entityStart + consumed;\n            this.index = this.sectionStart - 1;\n            this.cbs.onattribentity(cp);\n        }\n        else {\n            if (this.sectionStart < this.entityStart) {\n                this.cbs.ontext(this.sectionStart, this.entityStart);\n            }\n            this.sectionStart = this.entityStart + consumed;\n            this.index = this.sectionStart - 1;\n            this.cbs.ontextentity(cp, this.sectionStart);\n        }\n    }\n}\nexports[\"default\"] = Tokenizer;\n//# sourceMappingURL=Tokenizer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvZGlzdC9jb21tb25qcy9Ub2tlbml6ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0IsaUJBQWlCLGlCQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5Q0FBeUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL2hvbWUvenViYWlyL2Rlc2lnbi1pbi1zdHVkaW8tc2VydmljZS9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvZGlzdC9jb21tb25qcy9Ub2tlbml6ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlF1b3RlVHlwZSA9IHZvaWQgMDtcbmNvbnN0IGRlY29kZV8xID0gcmVxdWlyZShcImVudGl0aWVzL2RlY29kZVwiKTtcbnZhciBDaGFyQ29kZXM7XG4oZnVuY3Rpb24gKENoYXJDb2Rlcykge1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJUYWJcIl0gPSA5XSA9IFwiVGFiXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIk5ld0xpbmVcIl0gPSAxMF0gPSBcIk5ld0xpbmVcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiRm9ybUZlZWRcIl0gPSAxMl0gPSBcIkZvcm1GZWVkXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkNhcnJpYWdlUmV0dXJuXCJdID0gMTNdID0gXCJDYXJyaWFnZVJldHVyblwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJTcGFjZVwiXSA9IDMyXSA9IFwiU3BhY2VcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiRXhjbGFtYXRpb25NYXJrXCJdID0gMzNdID0gXCJFeGNsYW1hdGlvbk1hcmtcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiTnVtYmVyXCJdID0gMzVdID0gXCJOdW1iZXJcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiQW1wXCJdID0gMzhdID0gXCJBbXBcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiU2luZ2xlUXVvdGVcIl0gPSAzOV0gPSBcIlNpbmdsZVF1b3RlXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkRvdWJsZVF1b3RlXCJdID0gMzRdID0gXCJEb3VibGVRdW90ZVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJEYXNoXCJdID0gNDVdID0gXCJEYXNoXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIlNsYXNoXCJdID0gNDddID0gXCJTbGFzaFwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJaZXJvXCJdID0gNDhdID0gXCJaZXJvXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIk5pbmVcIl0gPSA1N10gPSBcIk5pbmVcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiU2VtaVwiXSA9IDU5XSA9IFwiU2VtaVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJMdFwiXSA9IDYwXSA9IFwiTHRcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiRXFcIl0gPSA2MV0gPSBcIkVxXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkd0XCJdID0gNjJdID0gXCJHdFwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJRdWVzdGlvbm1hcmtcIl0gPSA2M10gPSBcIlF1ZXN0aW9ubWFya1wiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJVcHBlckFcIl0gPSA2NV0gPSBcIlVwcGVyQVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJMb3dlckFcIl0gPSA5N10gPSBcIkxvd2VyQVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJVcHBlckZcIl0gPSA3MF0gPSBcIlVwcGVyRlwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJMb3dlckZcIl0gPSAxMDJdID0gXCJMb3dlckZcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiVXBwZXJaXCJdID0gOTBdID0gXCJVcHBlclpcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiTG93ZXJaXCJdID0gMTIyXSA9IFwiTG93ZXJaXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkxvd2VyWFwiXSA9IDEyMF0gPSBcIkxvd2VyWFwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJPcGVuaW5nU3F1YXJlQnJhY2tldFwiXSA9IDkxXSA9IFwiT3BlbmluZ1NxdWFyZUJyYWNrZXRcIjtcbn0pKENoYXJDb2RlcyB8fCAoQ2hhckNvZGVzID0ge30pKTtcbi8qKiBBbGwgdGhlIHN0YXRlcyB0aGUgdG9rZW5pemVyIGNhbiBiZSBpbi4gKi9cbnZhciBTdGF0ZTtcbihmdW5jdGlvbiAoU3RhdGUpIHtcbiAgICBTdGF0ZVtTdGF0ZVtcIlRleHRcIl0gPSAxXSA9IFwiVGV4dFwiO1xuICAgIFN0YXRlW1N0YXRlW1wiQmVmb3JlVGFnTmFtZVwiXSA9IDJdID0gXCJCZWZvcmVUYWdOYW1lXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJblRhZ05hbWVcIl0gPSAzXSA9IFwiSW5UYWdOYW1lXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJblNlbGZDbG9zaW5nVGFnXCJdID0gNF0gPSBcIkluU2VsZkNsb3NpbmdUYWdcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkJlZm9yZUNsb3NpbmdUYWdOYW1lXCJdID0gNV0gPSBcIkJlZm9yZUNsb3NpbmdUYWdOYW1lXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJbkNsb3NpbmdUYWdOYW1lXCJdID0gNl0gPSBcIkluQ2xvc2luZ1RhZ05hbWVcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkFmdGVyQ2xvc2luZ1RhZ05hbWVcIl0gPSA3XSA9IFwiQWZ0ZXJDbG9zaW5nVGFnTmFtZVwiO1xuICAgIC8vIEF0dHJpYnV0ZXNcbiAgICBTdGF0ZVtTdGF0ZVtcIkJlZm9yZUF0dHJpYnV0ZU5hbWVcIl0gPSA4XSA9IFwiQmVmb3JlQXR0cmlidXRlTmFtZVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiSW5BdHRyaWJ1dGVOYW1lXCJdID0gOV0gPSBcIkluQXR0cmlidXRlTmFtZVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiQWZ0ZXJBdHRyaWJ1dGVOYW1lXCJdID0gMTBdID0gXCJBZnRlckF0dHJpYnV0ZU5hbWVcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkJlZm9yZUF0dHJpYnV0ZVZhbHVlXCJdID0gMTFdID0gXCJCZWZvcmVBdHRyaWJ1dGVWYWx1ZVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiSW5BdHRyaWJ1dGVWYWx1ZURxXCJdID0gMTJdID0gXCJJbkF0dHJpYnV0ZVZhbHVlRHFcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkluQXR0cmlidXRlVmFsdWVTcVwiXSA9IDEzXSA9IFwiSW5BdHRyaWJ1dGVWYWx1ZVNxXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJbkF0dHJpYnV0ZVZhbHVlTnFcIl0gPSAxNF0gPSBcIkluQXR0cmlidXRlVmFsdWVOcVwiO1xuICAgIC8vIERlY2xhcmF0aW9uc1xuICAgIFN0YXRlW1N0YXRlW1wiQmVmb3JlRGVjbGFyYXRpb25cIl0gPSAxNV0gPSBcIkJlZm9yZURlY2xhcmF0aW9uXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJbkRlY2xhcmF0aW9uXCJdID0gMTZdID0gXCJJbkRlY2xhcmF0aW9uXCI7XG4gICAgLy8gUHJvY2Vzc2luZyBpbnN0cnVjdGlvbnNcbiAgICBTdGF0ZVtTdGF0ZVtcIkluUHJvY2Vzc2luZ0luc3RydWN0aW9uXCJdID0gMTddID0gXCJJblByb2Nlc3NpbmdJbnN0cnVjdGlvblwiO1xuICAgIC8vIENvbW1lbnRzICYgQ0RBVEFcbiAgICBTdGF0ZVtTdGF0ZVtcIkJlZm9yZUNvbW1lbnRcIl0gPSAxOF0gPSBcIkJlZm9yZUNvbW1lbnRcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkNEQVRBU2VxdWVuY2VcIl0gPSAxOV0gPSBcIkNEQVRBU2VxdWVuY2VcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkluU3BlY2lhbENvbW1lbnRcIl0gPSAyMF0gPSBcIkluU3BlY2lhbENvbW1lbnRcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkluQ29tbWVudExpa2VcIl0gPSAyMV0gPSBcIkluQ29tbWVudExpa2VcIjtcbiAgICAvLyBTcGVjaWFsIHRhZ3NcbiAgICBTdGF0ZVtTdGF0ZVtcIkJlZm9yZVNwZWNpYWxTXCJdID0gMjJdID0gXCJCZWZvcmVTcGVjaWFsU1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiQmVmb3JlU3BlY2lhbFRcIl0gPSAyM10gPSBcIkJlZm9yZVNwZWNpYWxUXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJTcGVjaWFsU3RhcnRTZXF1ZW5jZVwiXSA9IDI0XSA9IFwiU3BlY2lhbFN0YXJ0U2VxdWVuY2VcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkluU3BlY2lhbFRhZ1wiXSA9IDI1XSA9IFwiSW5TcGVjaWFsVGFnXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJbkVudGl0eVwiXSA9IDI2XSA9IFwiSW5FbnRpdHlcIjtcbn0pKFN0YXRlIHx8IChTdGF0ZSA9IHt9KSk7XG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoYykge1xuICAgIHJldHVybiAoYyA9PT0gQ2hhckNvZGVzLlNwYWNlIHx8XG4gICAgICAgIGMgPT09IENoYXJDb2Rlcy5OZXdMaW5lIHx8XG4gICAgICAgIGMgPT09IENoYXJDb2Rlcy5UYWIgfHxcbiAgICAgICAgYyA9PT0gQ2hhckNvZGVzLkZvcm1GZWVkIHx8XG4gICAgICAgIGMgPT09IENoYXJDb2Rlcy5DYXJyaWFnZVJldHVybik7XG59XG5mdW5jdGlvbiBpc0VuZE9mVGFnU2VjdGlvbihjKSB7XG4gICAgcmV0dXJuIGMgPT09IENoYXJDb2Rlcy5TbGFzaCB8fCBjID09PSBDaGFyQ29kZXMuR3QgfHwgaXNXaGl0ZXNwYWNlKGMpO1xufVxuZnVuY3Rpb24gaXNBU0NJSUFscGhhKGMpIHtcbiAgICByZXR1cm4gKChjID49IENoYXJDb2Rlcy5Mb3dlckEgJiYgYyA8PSBDaGFyQ29kZXMuTG93ZXJaKSB8fFxuICAgICAgICAoYyA+PSBDaGFyQ29kZXMuVXBwZXJBICYmIGMgPD0gQ2hhckNvZGVzLlVwcGVyWikpO1xufVxudmFyIFF1b3RlVHlwZTtcbihmdW5jdGlvbiAoUXVvdGVUeXBlKSB7XG4gICAgUXVvdGVUeXBlW1F1b3RlVHlwZVtcIk5vVmFsdWVcIl0gPSAwXSA9IFwiTm9WYWx1ZVwiO1xuICAgIFF1b3RlVHlwZVtRdW90ZVR5cGVbXCJVbnF1b3RlZFwiXSA9IDFdID0gXCJVbnF1b3RlZFwiO1xuICAgIFF1b3RlVHlwZVtRdW90ZVR5cGVbXCJTaW5nbGVcIl0gPSAyXSA9IFwiU2luZ2xlXCI7XG4gICAgUXVvdGVUeXBlW1F1b3RlVHlwZVtcIkRvdWJsZVwiXSA9IDNdID0gXCJEb3VibGVcIjtcbn0pKFF1b3RlVHlwZSB8fCAoZXhwb3J0cy5RdW90ZVR5cGUgPSBRdW90ZVR5cGUgPSB7fSkpO1xuLyoqXG4gKiBTZXF1ZW5jZXMgdXNlZCB0byBtYXRjaCBsb25nZXIgc3RyaW5ncy5cbiAqXG4gKiBXZSBkb24ndCBoYXZlIGBTY3JpcHRgLCBgU3R5bGVgLCBvciBgVGl0bGVgIGhlcmUuIEluc3RlYWQsIHdlIHJlLXVzZSB0aGUgKkVuZFxuICogc2VxdWVuY2VzIHdpdGggYW4gaW5jcmVhc2VkIG9mZnNldC5cbiAqL1xuY29uc3QgU2VxdWVuY2VzID0ge1xuICAgIENkYXRhOiBuZXcgVWludDhBcnJheShbMHg0MywgMHg0NCwgMHg0MSwgMHg1NCwgMHg0MSwgMHg1Yl0pLCAvLyBDREFUQVtcbiAgICBDZGF0YUVuZDogbmV3IFVpbnQ4QXJyYXkoWzB4NWQsIDB4NWQsIDB4M2VdKSwgLy8gXV0+XG4gICAgQ29tbWVudEVuZDogbmV3IFVpbnQ4QXJyYXkoWzB4MmQsIDB4MmQsIDB4M2VdKSwgLy8gYC0tPmBcbiAgICBTY3JpcHRFbmQ6IG5ldyBVaW50OEFycmF5KFsweDNjLCAweDJmLCAweDczLCAweDYzLCAweDcyLCAweDY5LCAweDcwLCAweDc0XSksIC8vIGA8L3NjcmlwdGBcbiAgICBTdHlsZUVuZDogbmV3IFVpbnQ4QXJyYXkoWzB4M2MsIDB4MmYsIDB4NzMsIDB4NzQsIDB4NzksIDB4NmMsIDB4NjVdKSwgLy8gYDwvc3R5bGVgXG4gICAgVGl0bGVFbmQ6IG5ldyBVaW50OEFycmF5KFsweDNjLCAweDJmLCAweDc0LCAweDY5LCAweDc0LCAweDZjLCAweDY1XSksIC8vIGA8L3RpdGxlYFxuICAgIFRleHRhcmVhRW5kOiBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4M2MsIDB4MmYsIDB4NzQsIDB4NjUsIDB4NzgsIDB4NzQsIDB4NjEsIDB4NzIsIDB4NjUsIDB4NjEsXG4gICAgXSksIC8vIGA8L3RleHRhcmVhYFxuICAgIFhtcEVuZDogbmV3IFVpbnQ4QXJyYXkoWzB4M2MsIDB4MmYsIDB4NzgsIDB4NmQsIDB4NzBdKSwgLy8gYDwveG1wYFxufTtcbmNsYXNzIFRva2VuaXplciB7XG4gICAgY29uc3RydWN0b3IoeyB4bWxNb2RlID0gZmFsc2UsIGRlY29kZUVudGl0aWVzID0gdHJ1ZSwgfSwgY2JzKSB7XG4gICAgICAgIHRoaXMuY2JzID0gY2JzO1xuICAgICAgICAvKiogVGhlIGN1cnJlbnQgc3RhdGUgdGhlIHRva2VuaXplciBpcyBpbi4gKi9cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlRleHQ7XG4gICAgICAgIC8qKiBUaGUgcmVhZCBidWZmZXIuICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICAgICAgLyoqIFRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY3Rpb24gdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgcmVhZC4gKi9cbiAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgICAvKiogVGhlIGluZGV4IHdpdGhpbiB0aGUgYnVmZmVyIHRoYXQgd2UgYXJlIGN1cnJlbnRseSBsb29raW5nIGF0LiAqL1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgLyoqIFRoZSBzdGFydCBvZiB0aGUgbGFzdCBlbnRpdHkuICovXG4gICAgICAgIHRoaXMuZW50aXR5U3RhcnQgPSAwO1xuICAgICAgICAvKiogU29tZSBiZWhhdmlvciwgZWcuIHdoZW4gZGVjb2RpbmcgZW50aXRpZXMsIGlzIGRvbmUgd2hpbGUgd2UgYXJlIGluIGFub3RoZXIgc3RhdGUuIFRoaXMga2VlcHMgdHJhY2sgb2YgdGhlIG90aGVyIHN0YXRlIHR5cGUuICovXG4gICAgICAgIHRoaXMuYmFzZVN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgLyoqIEZvciBzcGVjaWFsIHBhcnNpbmcgYmVoYXZpb3IgaW5zaWRlIG9mIHNjcmlwdCBhbmQgc3R5bGUgdGFncy4gKi9cbiAgICAgICAgdGhpcy5pc1NwZWNpYWwgPSBmYWxzZTtcbiAgICAgICAgLyoqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0b2tlbml6ZXIgaGFzIGJlZW4gcGF1c2VkLiAqL1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAvKiogVGhlIG9mZnNldCBvZiB0aGUgY3VycmVudCBidWZmZXIuICovXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VxdWVuY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMueG1sTW9kZSA9IHhtbE1vZGU7XG4gICAgICAgIHRoaXMuZGVjb2RlRW50aXRpZXMgPSBkZWNvZGVFbnRpdGllcztcbiAgICAgICAgdGhpcy5lbnRpdHlEZWNvZGVyID0gbmV3IGRlY29kZV8xLkVudGl0eURlY29kZXIoeG1sTW9kZSA/IGRlY29kZV8xLnhtbERlY29kZVRyZWUgOiBkZWNvZGVfMS5odG1sRGVjb2RlVHJlZSwgKGNwLCBjb25zdW1lZCkgPT4gdGhpcy5lbWl0Q29kZVBvaW50KGNwLCBjb25zdW1lZCkpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlRleHQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5iYXNlU3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgIH1cbiAgICB3cml0ZShjaHVuaykge1xuICAgICAgICB0aGlzLm9mZnNldCArPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gY2h1bms7XG4gICAgICAgIHRoaXMucGFyc2UoKTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICBpZiAodGhpcy5ydW5uaW5nKVxuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICB9XG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoICsgdGhpcy5vZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZVRleHQoYykge1xuICAgICAgICBpZiAoYyA9PT0gQ2hhckNvZGVzLkx0IHx8XG4gICAgICAgICAgICAoIXRoaXMuZGVjb2RlRW50aXRpZXMgJiYgdGhpcy5mYXN0Rm9yd2FyZFRvKENoYXJDb2Rlcy5MdCkpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCA+IHRoaXMuc2VjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYnMub250ZXh0KHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CZWZvcmVUYWdOYW1lO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGVjb2RlRW50aXRpZXMgJiYgYyA9PT0gQ2hhckNvZGVzLkFtcCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydEVudGl0eSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlU3BlY2lhbFN0YXJ0U2VxdWVuY2UoYykge1xuICAgICAgICBjb25zdCBpc0VuZCA9IHRoaXMuc2VxdWVuY2VJbmRleCA9PT0gdGhpcy5jdXJyZW50U2VxdWVuY2UubGVuZ3RoO1xuICAgICAgICBjb25zdCBpc01hdGNoID0gaXNFbmRcbiAgICAgICAgICAgID8gLy8gSWYgd2UgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLCBtYWtlIHN1cmUgdGhlIHRhZyBuYW1lIGhhcyBlbmRlZFxuICAgICAgICAgICAgICAgIGlzRW5kT2ZUYWdTZWN0aW9uKGMpXG4gICAgICAgICAgICA6IC8vIE90aGVyd2lzZSwgZG8gYSBjYXNlLWluc2Vuc2l0aXZlIGNvbXBhcmlzb25cbiAgICAgICAgICAgICAgICAoYyB8IDB4MjApID09PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZVt0aGlzLnNlcXVlbmNlSW5kZXhdO1xuICAgICAgICBpZiAoIWlzTWF0Y2gpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTcGVjaWFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzRW5kKSB7XG4gICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXgrKztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5UYWdOYW1lO1xuICAgICAgICB0aGlzLnN0YXRlSW5UYWdOYW1lKGMpO1xuICAgIH1cbiAgICAvKiogTG9vayBmb3IgYW4gZW5kIHRhZy4gRm9yIDx0aXRsZT4gdGFncywgYWxzbyBkZWNvZGUgZW50aXRpZXMuICovXG4gICAgc3RhdGVJblNwZWNpYWxUYWcoYykge1xuICAgICAgICBpZiAodGhpcy5zZXF1ZW5jZUluZGV4ID09PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuR3QgfHwgaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kT2ZUZXh0ID0gdGhpcy5pbmRleCAtIHRoaXMuY3VycmVudFNlcXVlbmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWN0aW9uU3RhcnQgPCBlbmRPZlRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3Bvb2YgdGhlIGluZGV4IHNvIHRoYXQgcmVwb3J0ZWQgbG9jYXRpb25zIG1hdGNoIHVwLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3R1YWxJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBlbmRPZlRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2JzLm9udGV4dCh0aGlzLnNlY3Rpb25TdGFydCwgZW5kT2ZUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGFjdHVhbEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmlzU3BlY2lhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gZW5kT2ZUZXh0ICsgMjsgLy8gU2tpcCBvdmVyIHRoZSBgPC9gXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluQ2xvc2luZ1RhZ05hbWUoYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBXZSBhcmUgZG9uZTsgc2tpcCB0aGUgcmVzdCBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoYyB8IDB4MjApID09PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZVt0aGlzLnNlcXVlbmNlSW5kZXhdKSB7XG4gICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlcXVlbmNlSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9PT0gU2VxdWVuY2VzLlRpdGxlRW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBwYXJzZSBlbnRpdGllcyBpbiA8dGl0bGU+IHRhZ3MuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVjb2RlRW50aXRpZXMgJiYgYyA9PT0gQ2hhckNvZGVzLkFtcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RW50aXR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5mYXN0Rm9yd2FyZFRvKENoYXJDb2Rlcy5MdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBPdXRzaWRlIG9mIDx0aXRsZT4gdGFncywgd2UgY2FuIGZhc3QtZm9yd2FyZC5cbiAgICAgICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgd2Ugc2VlIGEgYDxgLCBzZXQgdGhlIHNlcXVlbmNlIGluZGV4IHRvIDE7IHVzZWZ1bCBmb3IgZWcuIGA8PC9zY3JpcHQ+YC5cbiAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IE51bWJlcihjID09PSBDaGFyQ29kZXMuTHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlQ0RBVEFTZXF1ZW5jZShjKSB7XG4gICAgICAgIGlmIChjID09PSBTZXF1ZW5jZXMuQ2RhdGFbdGhpcy5zZXF1ZW5jZUluZGV4XSkge1xuICAgICAgICAgICAgaWYgKCsrdGhpcy5zZXF1ZW5jZUluZGV4ID09PSBTZXF1ZW5jZXMuQ2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluQ29tbWVudExpa2U7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VxdWVuY2UgPSBTZXF1ZW5jZXMuQ2RhdGFFbmQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JbkRlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUluRGVjbGFyYXRpb24oYyk7IC8vIFJlY29uc3VtZSB0aGUgY2hhcmFjdGVyXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiB3ZSB3YWl0IGZvciBvbmUgc3BlY2lmaWMgY2hhcmFjdGVyLCB3ZSBjYW4gc3BlZWQgdGhpbmdzIHVwXG4gICAgICogYnkgc2tpcHBpbmcgdGhyb3VnaCB0aGUgYnVmZmVyIHVudGlsIHdlIGZpbmQgaXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgd2FzIGZvdW5kLlxuICAgICAqL1xuICAgIGZhc3RGb3J3YXJkVG8oYykge1xuICAgICAgICB3aGlsZSAoKyt0aGlzLmluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoICsgdGhpcy5vZmZzZXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlci5jaGFyQ29kZUF0KHRoaXMuaW5kZXggLSB0aGlzLm9mZnNldCkgPT09IGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBXZSBpbmNyZW1lbnQgdGhlIGluZGV4IGF0IHRoZSBlbmQgb2YgdGhlIGBwYXJzZWAgbG9vcCxcbiAgICAgICAgICogc28gc2V0IGl0IHRvIGBidWZmZXIubGVuZ3RoIC0gMWAgaGVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVE9ETzogUmVmYWN0b3IgYHBhcnNlYCB0byBpbmNyZW1lbnQgaW5kZXggYmVmb3JlIGNhbGxpbmcgc3RhdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuYnVmZmVyLmxlbmd0aCArIHRoaXMub2Zmc2V0IC0gMTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21tZW50cyBhbmQgQ0RBVEEgZW5kIHdpdGggYC0tPmAgYW5kIGBdXT5gLlxuICAgICAqXG4gICAgICogVGhlaXIgY29tbW9uIHF1YWxpdGllcyBhcmU6XG4gICAgICogLSBUaGVpciBlbmQgc2VxdWVuY2VzIGhhdmUgYSBkaXN0aW5jdCBjaGFyYWN0ZXIgdGhleSBzdGFydCB3aXRoLlxuICAgICAqIC0gVGhhdCBjaGFyYWN0ZXIgaXMgdGhlbiByZXBlYXRlZCwgc28gd2UgaGF2ZSB0byBjaGVjayBtdWx0aXBsZSByZXBlYXRzLlxuICAgICAqIC0gQWxsIGNoYXJhY3RlcnMgYnV0IHRoZSBzdGFydCBjaGFyYWN0ZXIgb2YgdGhlIHNlcXVlbmNlIGNhbiBiZSBza2lwcGVkLlxuICAgICAqL1xuICAgIHN0YXRlSW5Db21tZW50TGlrZShjKSB7XG4gICAgICAgIGlmIChjID09PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZVt0aGlzLnNlcXVlbmNlSW5kZXhdKSB7XG4gICAgICAgICAgICBpZiAoKyt0aGlzLnNlcXVlbmNlSW5kZXggPT09IHRoaXMuY3VycmVudFNlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9PT0gU2VxdWVuY2VzLkNkYXRhRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2JzLm9uY2RhdGEodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgsIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYnMub25jb21tZW50KHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4LCAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2VxdWVuY2VJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRmFzdC1mb3J3YXJkIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHNlcXVlbmNlXG4gICAgICAgICAgICBpZiAodGhpcy5mYXN0Rm9yd2FyZFRvKHRoaXMuY3VycmVudFNlcXVlbmNlWzBdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gdGhpcy5jdXJyZW50U2VxdWVuY2VbdGhpcy5zZXF1ZW5jZUluZGV4IC0gMV0pIHtcbiAgICAgICAgICAgIC8vIEFsbG93IGxvbmcgc2VxdWVuY2VzLCBlZy4gLS0tPiwgXV1dPlxuICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIVE1MIG9ubHkgYWxsb3dzIEFTQ0lJIGFscGhhIGNoYXJhY3RlcnMgKGEteiBhbmQgQS1aKSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgdGFnIG5hbWUuXG4gICAgICpcbiAgICAgKiBYTUwgYWxsb3dzIGEgbG90IG1vcmUgY2hhcmFjdGVycyBoZXJlIChAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lU3RhcnRDaGFyKS5cbiAgICAgKiBXZSBhbGxvdyBhbnl0aGluZyB0aGF0IHdvdWxkbid0IGVuZCB0aGUgdGFnLlxuICAgICAqL1xuICAgIGlzVGFnU3RhcnRDaGFyKGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueG1sTW9kZSA/ICFpc0VuZE9mVGFnU2VjdGlvbihjKSA6IGlzQVNDSUlBbHBoYShjKTtcbiAgICB9XG4gICAgc3RhcnRTcGVjaWFsKHNlcXVlbmNlLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5pc1NwZWNpYWwgPSB0cnVlO1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9IHNlcXVlbmNlO1xuICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TcGVjaWFsU3RhcnRTZXF1ZW5jZTtcbiAgICB9XG4gICAgc3RhdGVCZWZvcmVUYWdOYW1lKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5FeGNsYW1hdGlvbk1hcmspIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CZWZvcmVEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gQ2hhckNvZGVzLlF1ZXN0aW9ubWFyaykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluUHJvY2Vzc2luZ0luc3RydWN0aW9uO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzVGFnU3RhcnRDaGFyKGMpKSB7XG4gICAgICAgICAgICBjb25zdCBsb3dlciA9IGMgfCAweDIwO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgaWYgKHRoaXMueG1sTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JblRhZ05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsb3dlciA9PT0gU2VxdWVuY2VzLlNjcmlwdEVuZFsyXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CZWZvcmVTcGVjaWFsUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxvd2VyID09PSBTZXF1ZW5jZXMuVGl0bGVFbmRbMl0gfHxcbiAgICAgICAgICAgICAgICBsb3dlciA9PT0gU2VxdWVuY2VzLlhtcEVuZFsyXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CZWZvcmVTcGVjaWFsVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JblRhZ05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gQ2hhckNvZGVzLlNsYXNoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlQ2xvc2luZ1RhZ05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVUZXh0KGMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlSW5UYWdOYW1lKGMpIHtcbiAgICAgICAgaWYgKGlzRW5kT2ZUYWdTZWN0aW9uKGMpKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbm9wZW50YWduYW1lKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gLTE7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlQXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVBdHRyaWJ1dGVOYW1lKGMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlQmVmb3JlQ2xvc2luZ1RhZ05hbWUoYykge1xuICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBDaGFyQ29kZXMuR3QpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuaXNUYWdTdGFydENoYXIoYylcbiAgICAgICAgICAgICAgICA/IFN0YXRlLkluQ2xvc2luZ1RhZ05hbWVcbiAgICAgICAgICAgICAgICA6IFN0YXRlLkluU3BlY2lhbENvbW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGVJbkNsb3NpbmdUYWdOYW1lKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5HdCB8fCBpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uY2xvc2V0YWcodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5BZnRlckNsb3NpbmdUYWdOYW1lO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUFmdGVyQ2xvc2luZ1RhZ05hbWUoYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGVBZnRlckNsb3NpbmdUYWdOYW1lKGMpIHtcbiAgICAgICAgLy8gU2tpcCBldmVyeXRoaW5nIHVudGlsIFwiPlwiXG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuR3QgfHwgdGhpcy5mYXN0Rm9yd2FyZFRvKENoYXJDb2Rlcy5HdCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZUJlZm9yZUF0dHJpYnV0ZU5hbWUoYykge1xuICAgICAgICBpZiAoYyA9PT0gQ2hhckNvZGVzLkd0KSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbm9wZW50YWdlbmQodGhpcy5pbmRleCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1NwZWNpYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5TcGVjaWFsVGFnO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gQ2hhckNvZGVzLlNsYXNoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5TZWxmQ2xvc2luZ1RhZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5BdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlSW5TZWxmQ2xvc2luZ1RhZyhjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuR3QpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uc2VsZmNsb3Npbmd0YWcodGhpcy5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgICAgICB0aGlzLmlzU3BlY2lhbCA9IGZhbHNlOyAvLyBSZXNldCBzcGVjaWFsIHN0YXRlLCBpbiBjYXNlIG9mIHNlbGYtY2xvc2luZyBzcGVjaWFsIHRhZ3NcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlQXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVBdHRyaWJ1dGVOYW1lKGMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlSW5BdHRyaWJ1dGVOYW1lKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5FcSB8fCBpc0VuZE9mVGFnU2VjdGlvbihjKSkge1xuICAgICAgICAgICAgdGhpcy5jYnMub25hdHRyaWJuYW1lKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5BZnRlckF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlQWZ0ZXJBdHRyaWJ1dGVOYW1lKGMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlQWZ0ZXJBdHRyaWJ1dGVOYW1lKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5FcSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJlZm9yZUF0dHJpYnV0ZVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IENoYXJDb2Rlcy5TbGFzaCB8fCBjID09PSBDaGFyQ29kZXMuR3QpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZW5kKFF1b3RlVHlwZS5Ob1ZhbHVlLCB0aGlzLnNlY3Rpb25TdGFydCk7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJlZm9yZUF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlQXR0cmlidXRlTmFtZShjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmF0dHJpYmVuZChRdW90ZVR5cGUuTm9WYWx1ZSwgdGhpcy5zZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluQXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZUJlZm9yZUF0dHJpYnV0ZVZhbHVlKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5Eb3VibGVRdW90ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluQXR0cmlidXRlVmFsdWVEcTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gQ2hhckNvZGVzLlNpbmdsZVF1b3RlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5BdHRyaWJ1dGVWYWx1ZVNxO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5BdHRyaWJ1dGVWYWx1ZU5xO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUluQXR0cmlidXRlVmFsdWVOb1F1b3RlcyhjKTsgLy8gUmVjb25zdW1lIHRva2VuXG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlSW5BdHRyaWJ1dGVWYWx1ZShjLCBxdW90ZSkge1xuICAgICAgICBpZiAoYyA9PT0gcXVvdGUgfHxcbiAgICAgICAgICAgICghdGhpcy5kZWNvZGVFbnRpdGllcyAmJiB0aGlzLmZhc3RGb3J3YXJkVG8ocXVvdGUpKSkge1xuICAgICAgICAgICAgdGhpcy5jYnMub25hdHRyaWJkYXRhKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gLTE7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmF0dHJpYmVuZChxdW90ZSA9PT0gQ2hhckNvZGVzLkRvdWJsZVF1b3RlXG4gICAgICAgICAgICAgICAgPyBRdW90ZVR5cGUuRG91YmxlXG4gICAgICAgICAgICAgICAgOiBRdW90ZVR5cGUuU2luZ2xlLCB0aGlzLmluZGV4ICsgMSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlQXR0cmlidXRlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRlY29kZUVudGl0aWVzICYmIGMgPT09IENoYXJDb2Rlcy5BbXApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRFbnRpdHkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZUluQXR0cmlidXRlVmFsdWVEb3VibGVRdW90ZXMoYykge1xuICAgICAgICB0aGlzLmhhbmRsZUluQXR0cmlidXRlVmFsdWUoYywgQ2hhckNvZGVzLkRvdWJsZVF1b3RlKTtcbiAgICB9XG4gICAgc3RhdGVJbkF0dHJpYnV0ZVZhbHVlU2luZ2xlUXVvdGVzKGMpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVJbkF0dHJpYnV0ZVZhbHVlKGMsIENoYXJDb2Rlcy5TaW5nbGVRdW90ZSk7XG4gICAgfVxuICAgIHN0YXRlSW5BdHRyaWJ1dGVWYWx1ZU5vUXVvdGVzKGMpIHtcbiAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSB8fCBjID09PSBDaGFyQ29kZXMuR3QpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZGF0YSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5jYnMub25hdHRyaWJlbmQoUXVvdGVUeXBlLlVucXVvdGVkLCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CZWZvcmVBdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZUF0dHJpYnV0ZU5hbWUoYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZWNvZGVFbnRpdGllcyAmJiBjID09PSBDaGFyQ29kZXMuQW1wKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RW50aXR5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGVCZWZvcmVEZWNsYXJhdGlvbihjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuT3BlbmluZ1NxdWFyZUJyYWNrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5DREFUQVNlcXVlbmNlO1xuICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPVxuICAgICAgICAgICAgICAgIGMgPT09IENoYXJDb2Rlcy5EYXNoXG4gICAgICAgICAgICAgICAgICAgID8gU3RhdGUuQmVmb3JlQ29tbWVudFxuICAgICAgICAgICAgICAgICAgICA6IFN0YXRlLkluRGVjbGFyYXRpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGVJbkRlY2xhcmF0aW9uKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5HdCB8fCB0aGlzLmZhc3RGb3J3YXJkVG8oQ2hhckNvZGVzLkd0KSkge1xuICAgICAgICAgICAgdGhpcy5jYnMub25kZWNsYXJhdGlvbih0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGVJblByb2Nlc3NpbmdJbnN0cnVjdGlvbihjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuR3QgfHwgdGhpcy5mYXN0Rm9yd2FyZFRvKENoYXJDb2Rlcy5HdCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZUJlZm9yZUNvbW1lbnQoYykge1xuICAgICAgICBpZiAoYyA9PT0gQ2hhckNvZGVzLkRhc2gpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JbkNvbW1lbnRMaWtlO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VxdWVuY2UgPSBTZXF1ZW5jZXMuQ29tbWVudEVuZDtcbiAgICAgICAgICAgIC8vIEFsbG93IHNob3J0IGNvbW1lbnRzIChlZy4gPCEtLT4pXG4gICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAyO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JbkRlY2xhcmF0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlSW5TcGVjaWFsQ29tbWVudChjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuR3QgfHwgdGhpcy5mYXN0Rm9yd2FyZFRvKENoYXJDb2Rlcy5HdCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uY29tbWVudCh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCwgMCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGVCZWZvcmVTcGVjaWFsUyhjKSB7XG4gICAgICAgIGNvbnN0IGxvd2VyID0gYyB8IDB4MjA7XG4gICAgICAgIGlmIChsb3dlciA9PT0gU2VxdWVuY2VzLlNjcmlwdEVuZFszXSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFNwZWNpYWwoU2VxdWVuY2VzLlNjcmlwdEVuZCwgNCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobG93ZXIgPT09IFNlcXVlbmNlcy5TdHlsZUVuZFszXSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFNwZWNpYWwoU2VxdWVuY2VzLlN0eWxlRW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JblRhZ05hbWU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlSW5UYWdOYW1lKGMpOyAvLyBDb25zdW1lIHRoZSB0b2tlbiBhZ2FpblxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlQmVmb3JlU3BlY2lhbFQoYykge1xuICAgICAgICBjb25zdCBsb3dlciA9IGMgfCAweDIwO1xuICAgICAgICBzd2l0Y2ggKGxvd2VyKSB7XG4gICAgICAgICAgICBjYXNlIFNlcXVlbmNlcy5UaXRsZUVuZFszXToge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGVjaWFsKFNlcXVlbmNlcy5UaXRsZUVuZCwgNCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNlcXVlbmNlcy5UZXh0YXJlYUVuZFszXToge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGVjaWFsKFNlcXVlbmNlcy5UZXh0YXJlYUVuZCwgNCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNlcXVlbmNlcy5YbXBFbmRbM106IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BlY2lhbChTZXF1ZW5jZXMuWG1wRW5kLCA0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5UYWdOYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJblRhZ05hbWUoYyk7IC8vIENvbnN1bWUgdGhlIHRva2VuIGFnYWluXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRFbnRpdHkoKSB7XG4gICAgICAgIHRoaXMuYmFzZVN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluRW50aXR5O1xuICAgICAgICB0aGlzLmVudGl0eVN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5lbnRpdHlEZWNvZGVyLnN0YXJ0RW50aXR5KHRoaXMueG1sTW9kZVxuICAgICAgICAgICAgPyBkZWNvZGVfMS5EZWNvZGluZ01vZGUuU3RyaWN0XG4gICAgICAgICAgICA6IHRoaXMuYmFzZVN0YXRlID09PSBTdGF0ZS5UZXh0IHx8XG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlU3RhdGUgPT09IFN0YXRlLkluU3BlY2lhbFRhZ1xuICAgICAgICAgICAgICAgID8gZGVjb2RlXzEuRGVjb2RpbmdNb2RlLkxlZ2FjeVxuICAgICAgICAgICAgICAgIDogZGVjb2RlXzEuRGVjb2RpbmdNb2RlLkF0dHJpYnV0ZSk7XG4gICAgfVxuICAgIHN0YXRlSW5FbnRpdHkoKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuZW50aXR5RGVjb2Rlci53cml0ZSh0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCAtIHRoaXMub2Zmc2V0KTtcbiAgICAgICAgLy8gSWYgYGxlbmd0aGAgaXMgcG9zaXRpdmUsIHdlIGFyZSBkb25lIHdpdGggdGhlIGVudGl0eS5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5iYXNlU3RhdGU7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuZW50aXR5U3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNYXJrIGJ1ZmZlciBhcyBjb25zdW1lZC5cbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLm9mZnNldCArIHRoaXMuYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGRhdGEgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGNvbnN1bWVkIGZyb20gdGhlIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgaW5zaWRlIG9mIHRleHQgb3IgYXR0cmlidXRlcywgZW1pdCB3aGF0IHdlIGFscmVhZHkgaGF2ZS5cbiAgICAgICAgaWYgKHRoaXMucnVubmluZyAmJiB0aGlzLnNlY3Rpb25TdGFydCAhPT0gdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlRleHQgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuSW5TcGVjaWFsVGFnICYmIHRoaXMuc2VxdWVuY2VJbmRleCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNicy5vbnRleHQodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkluQXR0cmlidXRlVmFsdWVEcSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLkluQXR0cmlidXRlVmFsdWVTcSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLkluQXR0cmlidXRlVmFsdWVOcSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZGF0YSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNob3VsZENvbnRpbnVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aCArIHRoaXMub2Zmc2V0ICYmIHRoaXMucnVubmluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgdGhyb3VnaCB0aGUgYnVmZmVyLCBjYWxsaW5nIHRoZSBmdW5jdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAqXG4gICAgICogU3RhdGVzIHRoYXQgYXJlIG1vcmUgbGlrZWx5IHRvIGJlIGhpdCBhcmUgaGlnaGVyIHVwLCBhcyBhIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LlxuICAgICAqL1xuICAgIHBhcnNlKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5zaG91bGRDb250aW51ZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gdGhpcy5idWZmZXIuY2hhckNvZGVBdCh0aGlzLmluZGV4IC0gdGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5UZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVUZXh0KGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5TcGVjaWFsU3RhcnRTZXF1ZW5jZToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlU3BlY2lhbFN0YXJ0U2VxdWVuY2UoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkluU3BlY2lhbFRhZzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5TcGVjaWFsVGFnKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5DREFUQVNlcXVlbmNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVDREFUQVNlcXVlbmNlKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JbkF0dHJpYnV0ZVZhbHVlRHE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluQXR0cmlidXRlVmFsdWVEb3VibGVRdW90ZXMoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkluQXR0cmlidXRlTmFtZToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5BdHRyaWJ1dGVOYW1lKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JbkNvbW1lbnRMaWtlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbkNvbW1lbnRMaWtlKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JblNwZWNpYWxDb21tZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJblNwZWNpYWxDb21tZW50KGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5CZWZvcmVBdHRyaWJ1dGVOYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVBdHRyaWJ1dGVOYW1lKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JblRhZ05hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluVGFnTmFtZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5DbG9zaW5nVGFnTmFtZToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5DbG9zaW5nVGFnTmFtZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuQmVmb3JlVGFnTmFtZToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlVGFnTmFtZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuQWZ0ZXJBdHRyaWJ1dGVOYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVBZnRlckF0dHJpYnV0ZU5hbWUoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkluQXR0cmlidXRlVmFsdWVTcToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5BdHRyaWJ1dGVWYWx1ZVNpbmdsZVF1b3RlcyhjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuQmVmb3JlQXR0cmlidXRlVmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZUF0dHJpYnV0ZVZhbHVlKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5CZWZvcmVDbG9zaW5nVGFnTmFtZToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlQ2xvc2luZ1RhZ05hbWUoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkFmdGVyQ2xvc2luZ1RhZ05hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUFmdGVyQ2xvc2luZ1RhZ05hbWUoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkJlZm9yZVNwZWNpYWxTOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVTcGVjaWFsUyhjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuQmVmb3JlU3BlY2lhbFQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZVNwZWNpYWxUKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JbkF0dHJpYnV0ZVZhbHVlTnE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluQXR0cmlidXRlVmFsdWVOb1F1b3RlcyhjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5TZWxmQ2xvc2luZ1RhZzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5TZWxmQ2xvc2luZ1RhZyhjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5EZWNsYXJhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5EZWNsYXJhdGlvbihjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuQmVmb3JlRGVjbGFyYXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZURlY2xhcmF0aW9uKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5CZWZvcmVDb21tZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVDb21tZW50KGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JblByb2Nlc3NpbmdJbnN0cnVjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkluRW50aXR5OiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbkVudGl0eSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkluRW50aXR5KSB7XG4gICAgICAgICAgICB0aGlzLmVudGl0eURlY29kZXIuZW5kKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5iYXNlU3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVUcmFpbGluZ0RhdGEoKTtcbiAgICAgICAgdGhpcy5jYnMub25lbmQoKTtcbiAgICB9XG4gICAgLyoqIEhhbmRsZSBhbnkgdHJhaWxpbmcgZGF0YS4gKi9cbiAgICBoYW5kbGVUcmFpbGluZ0RhdGEoKSB7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoICsgdGhpcy5vZmZzZXQ7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHJlbWFpbmluZyBkYXRhLCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgaWYgKHRoaXMuc2VjdGlvblN0YXJ0ID49IGVuZEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkluQ29tbWVudExpa2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9PT0gU2VxdWVuY2VzLkNkYXRhRW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYnMub25jZGF0YSh0aGlzLnNlY3Rpb25TdGFydCwgZW5kSW5kZXgsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYnMub25jb21tZW50KHRoaXMuc2VjdGlvblN0YXJ0LCBlbmRJbmRleCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuSW5UYWdOYW1lIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5CZWZvcmVBdHRyaWJ1dGVOYW1lIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5CZWZvcmVBdHRyaWJ1dGVWYWx1ZSB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuQWZ0ZXJBdHRyaWJ1dGVOYW1lIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkF0dHJpYnV0ZU5hbWUgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLkluQXR0cmlidXRlVmFsdWVTcSB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuSW5BdHRyaWJ1dGVWYWx1ZURxIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkF0dHJpYnV0ZVZhbHVlTnEgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLkluQ2xvc2luZ1RhZ05hbWUpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBJZiB3ZSBhcmUgY3VycmVudGx5IGluIGFuIG9wZW5pbmcgb3IgY2xvc2luZyB0YWcsIHVzIG5vdCBjYWxsaW5nIHRoZVxuICAgICAgICAgICAgICogcmVzcGVjdGl2ZSBjYWxsYmFjayBzaWduYWxzIHRoYXQgdGhlIHRhZyBzaG91bGQgYmUgaWdub3JlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYnMub250ZXh0KHRoaXMuc2VjdGlvblN0YXJ0LCBlbmRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdENvZGVQb2ludChjcCwgY29uc3VtZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVN0YXRlICE9PSBTdGF0ZS5UZXh0ICYmXG4gICAgICAgICAgICB0aGlzLmJhc2VTdGF0ZSAhPT0gU3RhdGUuSW5TcGVjaWFsVGFnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWN0aW9uU3RhcnQgPCB0aGlzLmVudGl0eVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYnMub25hdHRyaWJkYXRhKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmVudGl0eVN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5lbnRpdHlTdGFydCArIGNvbnN1bWVkO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc2VjdGlvblN0YXJ0IC0gMTtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZW50aXR5KGNwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlY3Rpb25TdGFydCA8IHRoaXMuZW50aXR5U3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNicy5vbnRleHQodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuZW50aXR5U3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmVudGl0eVN0YXJ0ICsgY29uc3VtZWQ7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5zZWN0aW9uU3RhcnQgLSAxO1xuICAgICAgICAgICAgdGhpcy5jYnMub250ZXh0ZW50aXR5KGNwLCB0aGlzLnNlY3Rpb25TdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBUb2tlbml6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ub2tlbml6ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/htmlparser2/dist/commonjs/Tokenizer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/htmlparser2/dist/commonjs/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/htmlparser2/dist/commonjs/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DomUtils = exports.getFeed = exports.ElementType = exports.QuoteType = exports.Tokenizer = exports.DefaultHandler = exports.DomHandler = exports.Parser = void 0;\nexports.parseDocument = parseDocument;\nexports.parseDOM = parseDOM;\nexports.createDocumentStream = createDocumentStream;\nexports.createDomStream = createDomStream;\nexports.parseFeed = parseFeed;\nconst Parser_js_1 = __webpack_require__(/*! ./Parser.js */ \"(ssr)/./node_modules/htmlparser2/dist/commonjs/Parser.js\");\nvar Parser_js_2 = __webpack_require__(/*! ./Parser.js */ \"(ssr)/./node_modules/htmlparser2/dist/commonjs/Parser.js\");\nObject.defineProperty(exports, \"Parser\", ({ enumerable: true, get: function () { return Parser_js_2.Parser; } }));\nconst domhandler_1 = __webpack_require__(/*! domhandler */ \"(ssr)/./node_modules/domhandler/lib/index.js\");\nvar domhandler_2 = __webpack_require__(/*! domhandler */ \"(ssr)/./node_modules/domhandler/lib/index.js\");\nObject.defineProperty(exports, \"DomHandler\", ({ enumerable: true, get: function () { return domhandler_2.DomHandler; } }));\n// Old name for DomHandler\nObject.defineProperty(exports, \"DefaultHandler\", ({ enumerable: true, get: function () { return domhandler_2.DomHandler; } }));\n// Helper methods\n/**\n * Parses the data, returns the resulting document.\n *\n * @param data The data that should be parsed.\n * @param options Optional options for the parser and DOM handler.\n */\nfunction parseDocument(data, options) {\n    const handler = new domhandler_1.DomHandler(undefined, options);\n    new Parser_js_1.Parser(handler, options).end(data);\n    return handler.root;\n}\n/**\n * Parses data, returns an array of the root nodes.\n *\n * Note that the root nodes still have a `Document` node as their parent.\n * Use `parseDocument` to get the `Document` node instead.\n *\n * @param data The data that should be parsed.\n * @param options Optional options for the parser and DOM handler.\n * @deprecated Use `parseDocument` instead.\n */\nfunction parseDOM(data, options) {\n    return parseDocument(data, options).children;\n}\n/**\n * Creates a parser instance, with an attached DOM handler.\n *\n * @param callback A callback that will be called once parsing has been completed, with the resulting document.\n * @param options Optional options for the parser and DOM handler.\n * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.\n */\nfunction createDocumentStream(callback, options, elementCallback) {\n    const handler = new domhandler_1.DomHandler((error) => callback(error, handler.root), options, elementCallback);\n    return new Parser_js_1.Parser(handler, options);\n}\n/**\n * Creates a parser instance, with an attached DOM handler.\n *\n * @param callback A callback that will be called once parsing has been completed, with an array of root nodes.\n * @param options Optional options for the parser and DOM handler.\n * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.\n * @deprecated Use `createDocumentStream` instead.\n */\nfunction createDomStream(callback, options, elementCallback) {\n    const handler = new domhandler_1.DomHandler(callback, options, elementCallback);\n    return new Parser_js_1.Parser(handler, options);\n}\nvar Tokenizer_js_1 = __webpack_require__(/*! ./Tokenizer.js */ \"(ssr)/./node_modules/htmlparser2/dist/commonjs/Tokenizer.js\");\nObject.defineProperty(exports, \"Tokenizer\", ({ enumerable: true, get: function () { return __importDefault(Tokenizer_js_1).default; } }));\nObject.defineProperty(exports, \"QuoteType\", ({ enumerable: true, get: function () { return Tokenizer_js_1.QuoteType; } }));\n/*\n * All of the following exports exist for backwards-compatibility.\n * They should probably be removed eventually.\n */\nexports.ElementType = __importStar(__webpack_require__(/*! domelementtype */ \"(ssr)/./node_modules/domelementtype/lib/index.js\"));\nconst domutils_1 = __webpack_require__(/*! domutils */ \"(ssr)/./node_modules/domutils/lib/index.js\");\nvar domutils_2 = __webpack_require__(/*! domutils */ \"(ssr)/./node_modules/domutils/lib/index.js\");\nObject.defineProperty(exports, \"getFeed\", ({ enumerable: true, get: function () { return domutils_2.getFeed; } }));\nconst parseFeedDefaultOptions = { xmlMode: true };\n/**\n * Parse a feed.\n *\n * @param feed The feed that should be parsed, as a string.\n * @param options Optionally, options for parsing. When using this, you should set `xmlMode` to `true`.\n */\nfunction parseFeed(feed, options = parseFeedDefaultOptions) {\n    return (0, domutils_1.getFeed)(parseDOM(feed, options));\n}\nexports.DomUtils = __importStar(__webpack_require__(/*! domutils */ \"(ssr)/./node_modules/domutils/lib/index.js\"));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvZGlzdC9jb21tb25qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGVBQWUsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxzQkFBc0IsR0FBRyxrQkFBa0IsR0FBRyxjQUFjO0FBQy9KLHFCQUFxQjtBQUNyQixnQkFBZ0I7QUFDaEIsNEJBQTRCO0FBQzVCLHVCQUF1QjtBQUN2QixpQkFBaUI7QUFDakIsb0JBQW9CLG1CQUFPLENBQUMsNkVBQWE7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsNkVBQWE7QUFDdkMsMENBQXlDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQy9HLHFCQUFxQixtQkFBTyxDQUFDLGdFQUFZO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLGdFQUFZO0FBQ3ZDLDhDQUE2QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN4SDtBQUNBLGtEQUFpRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBZ0I7QUFDN0MsNkNBQTRDLEVBQUUscUNBQXFDLG1EQUFtRCxFQUFDO0FBQ3ZJLDZDQUE0QyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBZ0I7QUFDM0QsbUJBQW1CLG1CQUFPLENBQUMsNERBQVU7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsNERBQVU7QUFDbkMsMkNBQTBDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2hILGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCLG1CQUFPLENBQUMsNERBQVU7QUFDbEQiLCJzb3VyY2VzIjpbIi9ob21lL3p1YmFpci9kZXNpZ24taW4tc3R1ZGlvLXNlcnZpY2Uvbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2Rpc3QvY29tbW9uanMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRG9tVXRpbHMgPSBleHBvcnRzLmdldEZlZWQgPSBleHBvcnRzLkVsZW1lbnRUeXBlID0gZXhwb3J0cy5RdW90ZVR5cGUgPSBleHBvcnRzLlRva2VuaXplciA9IGV4cG9ydHMuRGVmYXVsdEhhbmRsZXIgPSBleHBvcnRzLkRvbUhhbmRsZXIgPSBleHBvcnRzLlBhcnNlciA9IHZvaWQgMDtcbmV4cG9ydHMucGFyc2VEb2N1bWVudCA9IHBhcnNlRG9jdW1lbnQ7XG5leHBvcnRzLnBhcnNlRE9NID0gcGFyc2VET007XG5leHBvcnRzLmNyZWF0ZURvY3VtZW50U3RyZWFtID0gY3JlYXRlRG9jdW1lbnRTdHJlYW07XG5leHBvcnRzLmNyZWF0ZURvbVN0cmVhbSA9IGNyZWF0ZURvbVN0cmVhbTtcbmV4cG9ydHMucGFyc2VGZWVkID0gcGFyc2VGZWVkO1xuY29uc3QgUGFyc2VyX2pzXzEgPSByZXF1aXJlKFwiLi9QYXJzZXIuanNcIik7XG52YXIgUGFyc2VyX2pzXzIgPSByZXF1aXJlKFwiLi9QYXJzZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJzZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBhcnNlcl9qc18yLlBhcnNlcjsgfSB9KTtcbmNvbnN0IGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCJkb21oYW5kbGVyXCIpO1xudmFyIGRvbWhhbmRsZXJfMiA9IHJlcXVpcmUoXCJkb21oYW5kbGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRG9tSGFuZGxlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9taGFuZGxlcl8yLkRvbUhhbmRsZXI7IH0gfSk7XG4vLyBPbGQgbmFtZSBmb3IgRG9tSGFuZGxlclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGVmYXVsdEhhbmRsZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvbWhhbmRsZXJfMi5Eb21IYW5kbGVyOyB9IH0pO1xuLy8gSGVscGVyIG1ldGhvZHNcbi8qKlxuICogUGFyc2VzIHRoZSBkYXRhLCByZXR1cm5zIHRoZSByZXN1bHRpbmcgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdGhhdCBzaG91bGQgYmUgcGFyc2VkLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHBhcnNlciBhbmQgRE9NIGhhbmRsZXIuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRG9jdW1lbnQoZGF0YSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIodW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICBuZXcgUGFyc2VyX2pzXzEuUGFyc2VyKGhhbmRsZXIsIG9wdGlvbnMpLmVuZChkYXRhKTtcbiAgICByZXR1cm4gaGFuZGxlci5yb290O1xufVxuLyoqXG4gKiBQYXJzZXMgZGF0YSwgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcm9vdCBub2Rlcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIHJvb3Qgbm9kZXMgc3RpbGwgaGF2ZSBhIGBEb2N1bWVudGAgbm9kZSBhcyB0aGVpciBwYXJlbnQuXG4gKiBVc2UgYHBhcnNlRG9jdW1lbnRgIHRvIGdldCB0aGUgYERvY3VtZW50YCBub2RlIGluc3RlYWQuXG4gKlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdGhhdCBzaG91bGQgYmUgcGFyc2VkLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHBhcnNlciBhbmQgRE9NIGhhbmRsZXIuXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHBhcnNlRG9jdW1lbnRgIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRE9NKGRhdGEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcGFyc2VEb2N1bWVudChkYXRhLCBvcHRpb25zKS5jaGlsZHJlbjtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHBhcnNlciBpbnN0YW5jZSwgd2l0aCBhbiBhdHRhY2hlZCBET00gaGFuZGxlci5cbiAqXG4gKiBAcGFyYW0gY2FsbGJhY2sgQSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgcGFyc2luZyBoYXMgYmVlbiBjb21wbGV0ZWQsIHdpdGggdGhlIHJlc3VsdGluZyBkb2N1bWVudC5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBwYXJzZXIgYW5kIERPTSBoYW5kbGVyLlxuICogQHBhcmFtIGVsZW1lbnRDYWxsYmFjayBBbiBvcHRpb25hbCBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgYSB0YWcgaGFzIGJlZW4gY29tcGxldGVkIGluc2lkZSBvZiB0aGUgRE9NLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEb2N1bWVudFN0cmVhbShjYWxsYmFjaywgb3B0aW9ucywgZWxlbWVudENhbGxiYWNrKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IG5ldyBkb21oYW5kbGVyXzEuRG9tSGFuZGxlcigoZXJyb3IpID0+IGNhbGxiYWNrKGVycm9yLCBoYW5kbGVyLnJvb3QpLCBvcHRpb25zLCBlbGVtZW50Q2FsbGJhY2spO1xuICAgIHJldHVybiBuZXcgUGFyc2VyX2pzXzEuUGFyc2VyKGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgcGFyc2VyIGluc3RhbmNlLCB3aXRoIGFuIGF0dGFjaGVkIERPTSBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayBBIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBwYXJzaW5nIGhhcyBiZWVuIGNvbXBsZXRlZCwgd2l0aCBhbiBhcnJheSBvZiByb290IG5vZGVzLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHBhcnNlciBhbmQgRE9NIGhhbmRsZXIuXG4gKiBAcGFyYW0gZWxlbWVudENhbGxiYWNrIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgZXZlcnkgdGltZSBhIHRhZyBoYXMgYmVlbiBjb21wbGV0ZWQgaW5zaWRlIG9mIHRoZSBET00uXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGNyZWF0ZURvY3VtZW50U3RyZWFtYCBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEb21TdHJlYW0oY2FsbGJhY2ssIG9wdGlvbnMsIGVsZW1lbnRDYWxsYmFjaykge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIoY2FsbGJhY2ssIG9wdGlvbnMsIGVsZW1lbnRDYWxsYmFjayk7XG4gICAgcmV0dXJuIG5ldyBQYXJzZXJfanNfMS5QYXJzZXIoaGFuZGxlciwgb3B0aW9ucyk7XG59XG52YXIgVG9rZW5pemVyX2pzXzEgPSByZXF1aXJlKFwiLi9Ub2tlbml6ZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUb2tlbml6ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9faW1wb3J0RGVmYXVsdChUb2tlbml6ZXJfanNfMSkuZGVmYXVsdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlF1b3RlVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVG9rZW5pemVyX2pzXzEuUXVvdGVUeXBlOyB9IH0pO1xuLypcbiAqIEFsbCBvZiB0aGUgZm9sbG93aW5nIGV4cG9ydHMgZXhpc3QgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LlxuICogVGhleSBzaG91bGQgcHJvYmFibHkgYmUgcmVtb3ZlZCBldmVudHVhbGx5LlxuICovXG5leHBvcnRzLkVsZW1lbnRUeXBlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJkb21lbGVtZW50dHlwZVwiKSk7XG5jb25zdCBkb211dGlsc18xID0gcmVxdWlyZShcImRvbXV0aWxzXCIpO1xudmFyIGRvbXV0aWxzXzIgPSByZXF1aXJlKFwiZG9tdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRGZWVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb211dGlsc18yLmdldEZlZWQ7IH0gfSk7XG5jb25zdCBwYXJzZUZlZWREZWZhdWx0T3B0aW9ucyA9IHsgeG1sTW9kZTogdHJ1ZSB9O1xuLyoqXG4gKiBQYXJzZSBhIGZlZWQuXG4gKlxuICogQHBhcmFtIGZlZWQgVGhlIGZlZWQgdGhhdCBzaG91bGQgYmUgcGFyc2VkLCBhcyBhIHN0cmluZy5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsbHksIG9wdGlvbnMgZm9yIHBhcnNpbmcuIFdoZW4gdXNpbmcgdGhpcywgeW91IHNob3VsZCBzZXQgYHhtbE1vZGVgIHRvIGB0cnVlYC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VGZWVkKGZlZWQsIG9wdGlvbnMgPSBwYXJzZUZlZWREZWZhdWx0T3B0aW9ucykge1xuICAgIHJldHVybiAoMCwgZG9tdXRpbHNfMS5nZXRGZWVkKShwYXJzZURPTShmZWVkLCBvcHRpb25zKSk7XG59XG5leHBvcnRzLkRvbVV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJkb211dGlsc1wiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/htmlparser2/dist/commonjs/index.js\n");

/***/ })

};
;